{"version":3,"file":"static/js/712.ec4b126b.chunk.js","mappings":"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","sources":["ezyvuecore/three/examples/jsm/loaders/VTKLoader.js"],"sourcesContent":["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader\r\n} from '../../../build/three';\r\nimport * as fflate from '../libs/fflate.module.js';\r\n\r\nclass VTKLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( data ) {\r\n\r\n\t\tfunction parseASCII( data ) {\r\n\r\n\t\t\t// connectivity of the triangles\r\n\t\t\tconst indices = [];\r\n\r\n\t\t\t// triangles vertices\r\n\t\t\tconst positions = [];\r\n\r\n\t\t\t// red, green, blue colors in the range 0 to 1\r\n\t\t\tconst colors = [];\r\n\r\n\t\t\t// normal vector, one per vertex\r\n\t\t\tconst normals = [];\r\n\r\n\t\t\tlet result;\r\n\r\n\t\t\t// pattern for detecting the end of a number sequence\r\n\t\t\tconst patWord = /^[^\\d.\\s-]+/;\r\n\r\n\t\t\t// pattern for reading vertices, 3 floats or integers\r\n\t\t\tconst pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\r\n\r\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\r\n\t\t\t// the first integer is the number of polygon nodes\r\n\t\t\tconst patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\r\n\r\n\t\t\t// indicates start of vertex data section\r\n\t\t\tconst patPOINTS = /^POINTS /;\r\n\r\n\t\t\t// indicates start of polygon connectivity section\r\n\t\t\tconst patPOLYGONS = /^POLYGONS /;\r\n\r\n\t\t\t// indicates start of triangle strips section\r\n\t\t\tconst patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\r\n\r\n\t\t\t// POINT_DATA number_of_values\r\n\t\t\tconst patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\r\n\r\n\t\t\t// CELL_DATA number_of_polys\r\n\t\t\tconst patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\r\n\r\n\t\t\t// Start of color section\r\n\t\t\tconst patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\r\n\r\n\t\t\t// NORMALS Normals float\r\n\t\t\tconst patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\r\n\r\n\t\t\tlet inPointsSection = false;\r\n\t\t\tlet inPolygonsSection = false;\r\n\t\t\tlet inTriangleStripSection = false;\r\n\t\t\tlet inPointDataSection = false;\r\n\t\t\tlet inCellDataSection = false;\r\n\t\t\tlet inColorSection = false;\r\n\t\t\tlet inNormalsSection = false;\r\n\r\n\t\t\tconst lines = data.split( '\\n' );\r\n\r\n\t\t\tfor ( const i in lines ) {\r\n\r\n\t\t\t\tconst line = lines[ i ].trim();\r\n\r\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\r\n\r\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\r\n\r\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\r\n\r\n\t\t\t\t} else if ( inPointsSection ) {\r\n\r\n\t\t\t\t\t// get the vertices\r\n\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\r\n\r\n\t\t\t\t\t\tconst x = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\tconst y = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\tconst z = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\tpositions.push( x, y, z );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inPolygonsSection ) {\r\n\r\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\r\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\r\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\r\n\r\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\r\n\r\n\t\t\t\t\t\t\tconst i0 = parseInt( inds[ 0 ] );\r\n\t\t\t\t\t\t\tlet k = 1;\r\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; ++ j ) {\r\n\r\n\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ k ] );\r\n\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ k + 1 ] );\r\n\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\t\t\t\t\t\t\t\tk ++;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inTriangleStripSection ) {\r\n\r\n\t\t\t\t\tif ( ( result = patConnectivity.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\r\n\t\t\t\t\t\tconst numVertices = parseInt( result[ 1 ] );\r\n\t\t\t\t\t\tconst inds = result[ 2 ].split( /\\s+/ );\r\n\r\n\t\t\t\t\t\tif ( numVertices >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < numVertices - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( j % 2 === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\r\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 2 ] );\r\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 1 ] );\r\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tconst i0 = parseInt( inds[ j ] );\r\n\t\t\t\t\t\t\t\t\tconst i1 = parseInt( inds[ j + 1 ] );\r\n\t\t\t\t\t\t\t\t\tconst i2 = parseInt( inds[ j + 2 ] );\r\n\t\t\t\t\t\t\t\t\tindices.push( i0, i1, i2 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( inPointDataSection || inCellDataSection ) {\r\n\r\n\t\t\t\t\tif ( inColorSection ) {\r\n\r\n\t\t\t\t\t\t// Get the colors\r\n\r\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\r\n\r\n\t\t\t\t\t\t\tconst r = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\t\tconst g = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\t\tconst b = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\t\tcolors.push( r, g, b );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( inNormalsSection ) {\r\n\r\n\t\t\t\t\t\t// Get the normal vectors\r\n\r\n\t\t\t\t\t\twhile ( ( result = pat3Floats.exec( line ) ) !== null ) {\r\n\r\n\t\t\t\t\t\t\tif ( patWord.exec( line ) !== null ) break;\r\n\r\n\t\t\t\t\t\t\tconst nx = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\t\tconst ny = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\t\tconst nz = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\t\tnormals.push( nx, ny, nz );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( patPOLYGONS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patPOINTS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinPointsSection = true;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patTRIANGLE_STRIPS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = true;\r\n\r\n\t\t\t\t} else if ( patPOINT_DATA.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinPointDataSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patCELL_DATA.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinCellDataSection = true;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patCOLOR_SCALARS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinColorSection = true;\r\n\t\t\t\t\tinNormalsSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t} else if ( patNORMALS.exec( line ) !== null ) {\r\n\r\n\t\t\t\t\tinNormalsSection = true;\r\n\t\t\t\t\tinColorSection = false;\r\n\t\t\t\t\tinPointsSection = false;\r\n\t\t\t\t\tinPolygonsSection = false;\r\n\t\t\t\t\tinTriangleStripSection = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet geometry = new BufferGeometry();\r\n\t\t\tgeometry.setIndex( indices );\r\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\r\n\r\n\t\t\tif ( normals.length === positions.length ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors.length !== indices.length ) {\r\n\r\n\t\t\t\t// stagger\r\n\r\n\t\t\t\tif ( colors.length === positions.length ) {\r\n\r\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// cell\r\n\r\n\t\t\t\tgeometry = geometry.toNonIndexed();\r\n\t\t\t\tconst numTriangles = geometry.attributes.position.count / 3;\r\n\r\n\t\t\t\tif ( colors.length === ( numTriangles * 3 ) ) {\r\n\r\n\t\t\t\t\tconst newColors = [];\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < numTriangles; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst r = colors[ 3 * i + 0 ];\r\n\t\t\t\t\t\tconst g = colors[ 3 * i + 1 ];\r\n\t\t\t\t\t\tconst b = colors[ 3 * i + 2 ];\r\n\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\t\t\t\t\t\tnewColors.push( r, g, b );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.setAttribute( 'color', new Float32BufferAttribute( newColors, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data ) {\r\n\r\n\t\t\tconst buffer = new Uint8Array( data );\r\n\t\t\tconst dataView = new DataView( data );\r\n\r\n\t\t\t// Points and normals, by default, are empty\r\n\t\t\tlet points = [];\r\n\t\t\tlet normals = [];\r\n\t\t\tlet indices = [];\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tfunction findString( buffer, start ) {\r\n\r\n\t\t\t\tlet index = start;\r\n\t\t\t\tlet c = buffer[ index ];\r\n\t\t\t\tconst s = [];\r\n\t\t\t\twhile ( c !== 10 ) {\r\n\r\n\t\t\t\t\ts.push( String.fromCharCode( c ) );\r\n\t\t\t\t\tindex ++;\r\n\t\t\t\t\tc = buffer[ index ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { start: start,\r\n\t\t\t\t\tend: index,\r\n\t\t\t\t\tnext: index + 1,\r\n\t\t\t\t\tparsedString: s.join( '' ) };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet state, line;\r\n\r\n\t\t\twhile ( true ) {\r\n\r\n\t\t\t\t// Get a string\r\n\t\t\t\tstate = findString( buffer, index );\r\n\t\t\t\tline = state.parsedString;\r\n\r\n\t\t\t\tif ( line.indexOf( 'DATASET' ) === 0 ) {\r\n\r\n\t\t\t\t\tconst dataset = line.split( ' ' )[ 1 ];\r\n\r\n\t\t\t\t\tif ( dataset !== 'POLYDATA' ) throw new Error( 'Unsupported DATASET type: ' + dataset );\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'POINTS' ) === 0 ) {\r\n\r\n\t\t\t\t\t// Add the points\r\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\r\n\t\t\t\t\t// Each point is 3 4-byte floats\r\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\r\n\r\n\t\t\t\t\tpoints = new Float32Array( numberOfPoints * 3 );\r\n\r\n\t\t\t\t\tlet pointIndex = state.next;\r\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\r\n\r\n\t\t\t\t\t\tpoints[ 3 * i ] = dataView.getFloat32( pointIndex, false );\r\n\t\t\t\t\t\tpoints[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\r\n\t\t\t\t\t\tpoints[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\r\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'TRIANGLE_STRIPS' ) === 0 ) {\r\n\r\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\r\n\t\t\t\t\t// 4 byte integers\r\n\t\t\t\t\tconst count = size * 4;\r\n\r\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\t\t\t\t\tlet indicesIndex = 0;\r\n\r\n\t\t\t\t\tlet pointIndex = state.next;\r\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\r\n\r\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\r\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\r\n\t\t\t\t\t\tconst strip = [];\r\n\t\t\t\t\t\tpointIndex += 4;\r\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\r\n\r\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\r\n\t\t\t\t\t\t\tpointIndex += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\r\n\t\t\t\t\t\tfor ( let j = 0; j < indexCount - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tif ( j % 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'POLYGONS' ) === 0 ) {\r\n\r\n\t\t\t\t\tconst numberOfStrips = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\t\t\t\t\tconst size = parseInt( line.split( ' ' )[ 2 ], 10 );\r\n\t\t\t\t\t// 4 byte integers\r\n\t\t\t\t\tconst count = size * 4;\r\n\r\n\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\t\t\t\t\tlet indicesIndex = 0;\r\n\r\n\t\t\t\t\tlet pointIndex = state.next;\r\n\t\t\t\t\tfor ( let i = 0; i < numberOfStrips; i ++ ) {\r\n\r\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\r\n\t\t\t\t\t\tconst indexCount = dataView.getInt32( pointIndex, false );\r\n\t\t\t\t\t\tconst strip = [];\r\n\t\t\t\t\t\tpointIndex += 4;\r\n\t\t\t\t\t\tfor ( let s = 0; s < indexCount; s ++ ) {\r\n\r\n\t\t\t\t\t\t\tstrip.push( dataView.getInt32( pointIndex, false ) );\r\n\t\t\t\t\t\t\tpointIndex += 4;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\r\n\t\t\t\t\t\tfor ( let j = 1; j < indexCount - 1; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ 0 ];\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// increment our next pointer\r\n\t\t\t\t\tstate.next = state.next + count + 1;\r\n\r\n\t\t\t\t} else if ( line.indexOf( 'POINT_DATA' ) === 0 ) {\r\n\r\n\t\t\t\t\tconst numberOfPoints = parseInt( line.split( ' ' )[ 1 ], 10 );\r\n\r\n\t\t\t\t\t// Grab the next line\r\n\t\t\t\t\tstate = findString( buffer, state.next );\r\n\r\n\t\t\t\t\t// Now grab the binary data\r\n\t\t\t\t\tconst count = numberOfPoints * 4 * 3;\r\n\r\n\t\t\t\t\tnormals = new Float32Array( numberOfPoints * 3 );\r\n\t\t\t\t\tlet pointIndex = state.next;\r\n\t\t\t\t\tfor ( let i = 0; i < numberOfPoints; i ++ ) {\r\n\r\n\t\t\t\t\t\tnormals[ 3 * i ] = dataView.getFloat32( pointIndex, false );\r\n\t\t\t\t\t\tnormals[ 3 * i + 1 ] = dataView.getFloat32( pointIndex + 4, false );\r\n\t\t\t\t\t\tnormals[ 3 * i + 2 ] = dataView.getFloat32( pointIndex + 8, false );\r\n\t\t\t\t\t\tpointIndex += 12;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Increment past our data\r\n\t\t\t\t\tstate.next = state.next + count;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment index\r\n\t\t\t\tindex = state.next;\r\n\r\n\t\t\t\tif ( index >= buffer.byteLength ) {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst geometry = new BufferGeometry();\r\n\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\r\n\r\n\t\t\tif ( normals.length === points.length ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Float32Concat( first, second ) {\r\n\r\n\t\t\tconst firstLength = first.length, result = new Float32Array( firstLength + second.length );\r\n\r\n\t\t\tresult.set( first );\r\n\t\t\tresult.set( second, firstLength );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\tfunction Int32Concat( first, second ) {\r\n\r\n\t\t\tconst firstLength = first.length, result = new Int32Array( firstLength + second.length );\r\n\r\n\t\t\tresult.set( first );\r\n\t\t\tresult.set( second, firstLength );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseXML( stringFile ) {\r\n\r\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\r\n\r\n\t\t\tfunction xmlToJson( xml ) {\r\n\r\n\t\t\t\t// Create the return object\r\n\t\t\t\tlet obj = {};\r\n\r\n\t\t\t\tif ( xml.nodeType === 1 ) { // element\r\n\r\n\t\t\t\t\t// do attributes\r\n\r\n\t\t\t\t\tif ( xml.attributes ) {\r\n\r\n\t\t\t\t\t\tif ( xml.attributes.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\tobj[ 'attributes' ] = {};\r\n\r\n\t\t\t\t\t\t\tfor ( let j = 0; j < xml.attributes.length; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tconst attribute = xml.attributes.item( j );\r\n\t\t\t\t\t\t\t\tobj[ 'attributes' ][ attribute.nodeName ] = attribute.nodeValue.trim();\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( xml.nodeType === 3 ) { // text\r\n\r\n\t\t\t\t\tobj = xml.nodeValue.trim();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// do children\r\n\t\t\t\tif ( xml.hasChildNodes() ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst item = xml.childNodes.item( i );\r\n\t\t\t\t\t\tconst nodeName = item.nodeName;\r\n\r\n\t\t\t\t\t\tif ( typeof obj[ nodeName ] === 'undefined' ) {\r\n\r\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\r\n\r\n\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ] = tmp;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tif ( typeof obj[ nodeName ].push === 'undefined' ) {\r\n\r\n\t\t\t\t\t\t\t\tconst old = obj[ nodeName ];\r\n\t\t\t\t\t\t\t\tobj[ nodeName ] = [ old ];\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tconst tmp = xmlToJson( item );\r\n\r\n\t\t\t\t\t\t\tif ( tmp !== '' ) obj[ nodeName ].push( tmp );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn obj;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Taken from Base64-js\r\n\t\t\tfunction Base64toByteArray( b64 ) {\r\n\r\n\t\t\t\tconst Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\r\n\t\t\t\tconst revLookup = [];\r\n\t\t\t\tconst code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n\t\t\t\tfor ( let i = 0, l = code.length; i < l; ++ i ) {\r\n\r\n\t\t\t\t\trevLookup[ code.charCodeAt( i ) ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\trevLookup[ '-'.charCodeAt( 0 ) ] = 62;\r\n\t\t\t\trevLookup[ '_'.charCodeAt( 0 ) ] = 63;\r\n\r\n\t\t\t\tconst len = b64.length;\r\n\r\n\t\t\t\tif ( len % 4 > 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Invalid string. Length must be a multiple of 4' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst placeHolders = b64[ len - 2 ] === '=' ? 2 : b64[ len - 1 ] === '=' ? 1 : 0;\r\n\t\t\t\tconst arr = new Arr( len * 3 / 4 - placeHolders );\r\n\t\t\t\tconst l = placeHolders > 0 ? len - 4 : len;\r\n\r\n\t\t\t\tlet L = 0;\r\n\t\t\t\tlet i, j;\r\n\r\n\t\t\t\tfor ( i = 0, j = 0; i < l; i += 4, j += 3 ) {\r\n\r\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 18 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 12 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] << 6 ) | revLookup[ b64.charCodeAt( i + 3 ) ];\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF0000 ) >> 16;\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp & 0xFF00 ) >> 8;\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( placeHolders === 2 ) {\r\n\r\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 2 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] >> 4 );\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t} else if ( placeHolders === 1 ) {\r\n\r\n\t\t\t\t\tconst tmp = ( revLookup[ b64.charCodeAt( i ) ] << 10 ) | ( revLookup[ b64.charCodeAt( i + 1 ) ] << 4 ) | ( revLookup[ b64.charCodeAt( i + 2 ) ] >> 2 );\r\n\t\t\t\t\tarr[ L ++ ] = ( tmp >> 8 ) & 0xFF;\r\n\t\t\t\t\tarr[ L ++ ] = tmp & 0xFF;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn arr;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction parseDataArray( ele, compressed ) {\r\n\r\n\t\t\t\tlet numBytes = 0;\r\n\r\n\t\t\t\tif ( json.attributes.header_type === 'UInt64' ) {\r\n\r\n\t\t\t\t\tnumBytes = 8;\r\n\r\n\t\t\t\t}\telse if ( json.attributes.header_type === 'UInt32' ) {\r\n\r\n\t\t\t\t\tnumBytes = 4;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet txt, content;\r\n\r\n\t\t\t\t// Check the format\r\n\t\t\t\tif ( ele.attributes.format === 'binary' && compressed ) {\r\n\r\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\ttxt = new Float32Array( );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\ttxt = new Int32Array( );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// VTP data with the header has the following structure:\r\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\r\n\t\t\t\t\t// [#blocks] = Number of blocks\r\n\t\t\t\t\t// [#u-size] = Block size before compression\r\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\r\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\r\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\r\n\r\n\t\t\t\t\tconst textNode = ele[ '#text' ];\r\n\t\t\t\t\tconst rawData = Array.isArray( textNode ) ? textNode[ 0 ] : textNode;\r\n\r\n\t\t\t\t\tconst byteData = Base64toByteArray( rawData );\r\n\r\n\t\t\t\t\t// Each data point consists of 8 bits regardless of the header type\r\n\t\t\t\t\tconst dataPointSize = 8;\r\n\r\n\t\t\t\t\tlet blocks = byteData[ 0 ];\r\n\t\t\t\t\tfor ( let i = 1; i < numBytes - 1; i ++ ) {\r\n\r\n\t\t\t\t\t\tblocks = blocks | ( byteData[ i ] << ( i * dataPointSize ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet headerSize = ( blocks + 3 ) * numBytes;\r\n\t\t\t\t\tconst padding = ( ( headerSize % 3 ) > 0 ) ? 3 - ( headerSize % 3 ) : 0;\r\n\t\t\t\t\theaderSize = headerSize + padding;\r\n\r\n\t\t\t\t\tconst dataOffsets = [];\r\n\t\t\t\t\tlet currentOffset = headerSize;\r\n\t\t\t\t\tdataOffsets.push( currentOffset );\r\n\r\n\t\t\t\t\t// Get the blocks sizes after the compression.\r\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\r\n\t\t\t\t\tconst cSizeStart = 3 * numBytes;\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < blocks; i ++ ) {\r\n\r\n\t\t\t\t\t\tlet currentBlockSize = byteData[ i * numBytes + cSizeStart ];\r\n\r\n\t\t\t\t\t\tfor ( let j = 1; j < numBytes - 1; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | ( byteData[ i * numBytes + cSizeStart + j ] << ( j * dataPointSize ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\r\n\t\t\t\t\t\tdataOffsets.push( currentOffset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < dataOffsets.length - 1; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst data = fflate.unzlibSync( byteData.slice( dataOffsets[ i ], dataOffsets[ i + 1 ] ) );\r\n\t\t\t\t\t\tcontent = data.buffer;\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\t\tcontent = new Float32Array( content );\r\n\t\t\t\t\t\t\ttxt = Float32Concat( txt, content );\r\n\r\n\t\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' || ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\t\tcontent = new Int32Array( content );\r\n\t\t\t\t\t\t\ttxt = Int32Concat( txt, content );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete ele[ '#text' ];\r\n\r\n\t\t\t\t\tif ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\r\n\r\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ele.attributes.format === 'binary' && ! compressed ) {\r\n\r\n\t\t\t\t\t\tcontent = Base64toByteArray( ele[ '#text' ] );\r\n\r\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\r\n\t\t\t\t\t\t// [#bytes][DATA]\r\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\r\n\t\t\t\t\t\tcontent = content.slice( numBytes ).buffer;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( ele[ '#text' ] ) {\r\n\r\n\t\t\t\t\t\t\tcontent = ele[ '#text' ].split( /\\s+/ ).filter( function ( el ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( el !== '' ) return el;\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tcontent = new Int32Array( 0 ).buffer;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tdelete ele[ '#text' ];\r\n\r\n\t\t\t\t\t// Get the content and optimize it\r\n\t\t\t\t\tif ( ele.attributes.type === 'Float32' ) {\r\n\r\n\t\t\t\t\t\ttxt = new Float32Array( content );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int32' ) {\r\n\r\n\t\t\t\t\t\ttxt = new Int32Array( content );\r\n\r\n\t\t\t\t\t} else if ( ele.attributes.type === 'Int64' ) {\r\n\r\n\t\t\t\t\t\ttxt = new Int32Array( content );\r\n\r\n\t\t\t\t\t\tif ( ele.attributes.format === 'binary' ) {\r\n\r\n\t\t\t\t\t\t\ttxt = txt.filter( function ( el, idx ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( idx % 2 !== 1 ) return true;\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\r\n\r\n\t\t\t\treturn txt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Main part\r\n\t\t\t// Get Dom\r\n\t\t\tconst dom = new DOMParser().parseFromString( stringFile, 'application/xml' );\r\n\r\n\t\t\t// Get the doc\r\n\t\t\tconst doc = dom.documentElement;\r\n\t\t\t// Convert to json\r\n\t\t\tconst json = xmlToJson( doc );\r\n\t\t\tlet points = [];\r\n\t\t\tlet normals = [];\r\n\t\t\tlet indices = [];\r\n\r\n\t\t\tif ( json.PolyData ) {\r\n\r\n\t\t\t\tconst piece = json.PolyData.Piece;\r\n\t\t\t\tconst compressed = json.attributes.hasOwnProperty( 'compressor' );\r\n\r\n\t\t\t\t// Can be optimized\r\n\t\t\t\t// Loop through the sections\r\n\t\t\t\tconst sections = [ 'PointData', 'Points', 'Strips', 'Polys' ];// +['CellData', 'Verts', 'Lines'];\r\n\t\t\t\tlet sectionIndex = 0;\r\n\t\t\t\tconst numberOfSections = sections.length;\r\n\r\n\t\t\t\twhile ( sectionIndex < numberOfSections ) {\r\n\r\n\t\t\t\t\tconst section = piece[ sections[ sectionIndex ] ];\r\n\r\n\t\t\t\t\t// If it has a DataArray in it\r\n\r\n\t\t\t\t\tif ( section && section.DataArray ) {\r\n\r\n\t\t\t\t\t\t// Depending on the number of DataArrays\r\n\r\n\t\t\t\t\t\tlet arr;\r\n\r\n\t\t\t\t\t\tif ( Array.isArray( section.DataArray ) ) {\r\n\r\n\t\t\t\t\t\t\tarr = section.DataArray;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tarr = [ section.DataArray ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet dataArrayIndex = 0;\r\n\t\t\t\t\t\tconst numberOfDataArrays = arr.length;\r\n\r\n\t\t\t\t\t\twhile ( dataArrayIndex < numberOfDataArrays ) {\r\n\r\n\t\t\t\t\t\t\t// Parse the DataArray\r\n\t\t\t\t\t\t\tif ( ( '#text' in arr[ dataArrayIndex ] ) && ( arr[ dataArrayIndex ][ '#text' ].length > 0 ) ) {\r\n\r\n\t\t\t\t\t\t\t\tarr[ dataArrayIndex ].text = parseDataArray( arr[ dataArrayIndex ], compressed );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tdataArrayIndex ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tswitch ( sections[ sectionIndex ] ) {\r\n\r\n\t\t\t\t\t\t\t// if iti is point data\r\n\t\t\t\t\t\t\tcase 'PointData':\r\n\r\n\t\t\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\r\n\t\t\t\t\t\t\t\t\tconst normalsName = section.attributes.Normals;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = arr.length; i < len; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( normalsName === arr[ i ].attributes.Name ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tconst components = arr[ i ].attributes.NumberOfComponents;\r\n\t\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array( numberOfPoints * components );\r\n\t\t\t\t\t\t\t\t\t\t\t\tnormals.set( arr[ i ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is points\r\n\t\t\t\t\t\t\tcase 'Points':\r\n\r\n\t\t\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t\t\tconst numberOfPoints = parseInt( piece.attributes.NumberOfPoints );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( numberOfPoints > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst components = section.DataArray.attributes.NumberOfComponents;\r\n\t\t\t\t\t\t\t\t\t\tpoints = new Float32Array( numberOfPoints * components );\r\n\t\t\t\t\t\t\t\t\t\tpoints.set( section.DataArray.text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is strips\r\n\t\t\t\t\t\t\tcase 'Strips':\r\n\r\n\t\t\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t\t\tconst numberOfStrips = parseInt( piece.attributes.NumberOfStrips );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( numberOfStrips > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\r\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\r\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\r\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfStrips + connectivity.length;\r\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfStrips );\r\n\r\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t\tfor ( let i = 0, len = numberOfStrips; i < len; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst strip = [];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tfor ( let s = 0, len1 = offset[ i ], len0 = 0; s < len1 - len0; s ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tstrip.push( connectivity[ s ] );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tfor ( let j = 0, len1 = offset[ i ], len0 = 0; j < len1 - len0 - 2; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( j % 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 1 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = strip[ j + 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tif ( i > 0 ) len0 = offset[ i - 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t// if it is polys\r\n\t\t\t\t\t\t\tcase 'Polys':\r\n\r\n\t\t\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t\t\tconst numberOfPolys = parseInt( piece.attributes.NumberOfPolys );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( numberOfPolys > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst connectivity = new Int32Array( section.DataArray[ 0 ].text.length );\r\n\t\t\t\t\t\t\t\t\t\tconst offset = new Int32Array( section.DataArray[ 1 ].text.length );\r\n\t\t\t\t\t\t\t\t\t\tconnectivity.set( section.DataArray[ 0 ].text, 0 );\r\n\t\t\t\t\t\t\t\t\t\toffset.set( section.DataArray[ 1 ].text, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst size = numberOfPolys + connectivity.length;\r\n\t\t\t\t\t\t\t\t\t\tindices = new Uint32Array( 3 * size - 9 * numberOfPolys );\r\n\t\t\t\t\t\t\t\t\t\tlet indicesIndex = 0, connectivityIndex = 0;\r\n\t\t\t\t\t\t\t\t\t\tlet i = 0, len0 = 0;\r\n\t\t\t\t\t\t\t\t\t\tconst len = numberOfPolys;\r\n\r\n\t\t\t\t\t\t\t\t\t\twhile ( i < len ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconst poly = [];\r\n\t\t\t\t\t\t\t\t\t\t\tlet s = 0;\r\n\t\t\t\t\t\t\t\t\t\t\tconst len1 = offset[ i ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t\twhile ( s < len1 - len0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tpoly.push( connectivity[ connectivityIndex ++ ] );\r\n\t\t\t\t\t\t\t\t\t\t\t\ts ++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tlet j = 1;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\twhile ( j < len1 - len0 - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ 0 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tindices[ indicesIndex ++ ] = poly[ j + 1 ];\r\n\t\t\t\t\t\t\t\t\t\t\t\tj ++;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ti ++;\r\n\t\t\t\t\t\t\t\t\t\t\tlen0 = offset[ i - 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsectionIndex ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst geometry = new BufferGeometry();\r\n\t\t\t\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\r\n\t\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( points, 3 ) );\r\n\r\n\t\t\t\tif ( normals.length === points.length ) {\r\n\r\n\t\t\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'Unsupported DATASET type' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst textDecoder = new TextDecoder();\r\n\r\n\t\t// get the 5 first lines of the files to check if there is the key word binary\r\n\t\tconst meta = textDecoder.decode( new Uint8Array( data, 0, 250 ) ).split( '\\n' );\r\n\r\n\t\tif ( meta[ 0 ].indexOf( 'xml' ) !== - 1 ) {\r\n\r\n\t\t\treturn parseXML( textDecoder.decode( data ) );\r\n\r\n\t\t} else if ( meta[ 2 ].includes( 'ASCII' ) ) {\r\n\r\n\t\t\treturn parseASCII( textDecoder.decode( data ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn parseBinary( data );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { VTKLoader };\r\n"],"names":["VTKLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","url","onLoad","onProgress","onError","scope","this","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","data","Float32Concat","first","second","firstLength","length","result","Float32Array","set","Int32Concat","Int32Array","textDecoder","TextDecoder","meta","decode","Uint8Array","split","indexOf","stringFile","Base64toByteArray","b64","Arr","Array","revLookup","code","i","charCodeAt","len","Error","j","placeHolders","arr","l","L","tmp","parseDataArray","ele","compressed","txt","content","numBytes","json","attributes","header_type","format","type","textNode","byteData","isArray","blocks","headerSize","dataOffsets","currentOffset","push","cSizeStart","currentBlockSize","fflate","slice","buffer","filter","el","idx","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","trim","hasChildNodes","childNodes","old","DOMParser","parseFromString","documentElement","points","normals","indices","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","dataArrayIndex","numberOfDataArrays","numberOfPoints","parseInt","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","numberOfStrips","NumberOfStrips","connectivity","offset","size","Uint32Array","indicesIndex","strip","s","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","geometry","BufferGeometry","setIndex","BufferAttribute","setAttribute","parseXML","includes","positions","colors","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","line","dataset","exec","x","parseFloat","y","z","numVertices","inds","i0","k","i1","i2","r","g","b","nx","ny","nz","Float32BufferAttribute","numTriangles","toNonIndexed","position","count","newColors","parseASCII","state","dataView","DataView","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","pointIndex","getFloat32","indexCount","getInt32","byteLength","parseBinary","Loader"],"sourceRoot":""}