{"version":3,"file":"static/js/3324.513cbb04.chunk.js","mappings":"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","sources":["ezyvuecore/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import {\r\n\tBox2,\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader,\r\n\tMatrix3,\r\n\tPath,\r\n\tShape,\r\n\tShapePath,\r\n\tShapeUtils,\r\n\tVector2,\r\n\tVector3\r\n} from '../../../build/three';\r\n\r\nclass SVGLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\t// Default dots per inch\r\n\t\tthis.defaultDPI = 90;\r\n\r\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\r\n\t\tthis.defaultUnit = 'px';\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( scope.manager );\r\n\t\tloader.setPath( scope.path );\r\n\t\tloader.setRequestHeader( scope.requestHeader );\r\n\t\tloader.setWithCredentials( scope.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( text ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tfunction parseNode( node, style ) {\r\n\r\n\t\t\tif ( node.nodeType !== 1 ) return;\r\n\r\n\t\t\tconst transform = getNodeTransform( node );\r\n\r\n\t\t\tlet isDefsNode = false;\r\n\r\n\t\t\tlet path = null;\r\n\r\n\t\t\tswitch ( node.nodeName ) {\r\n\r\n\t\t\t\tcase 'svg':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'style':\r\n\t\t\t\t\tparseCSSStylesheet( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'g':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'path':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'rect':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseRectNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polygon':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolygonNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'polyline':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parsePolylineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'circle':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseCircleNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'ellipse':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseEllipseNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'line':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\t\t\t\t\tpath = parseLineNode( node );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'defs':\r\n\t\t\t\t\tisDefsNode = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'use':\r\n\t\t\t\t\tstyle = parseStyle( node, style );\r\n\r\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\r\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\r\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\r\n\t\t\t\t\tif ( usedNode ) {\r\n\r\n\t\t\t\t\t\tparseNode( usedNode, style );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// console.log( node );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( path ) {\r\n\r\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\r\n\r\n\t\t\t\t\tpath.color.setStyle( style.fill );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttransformPath( path, currentTransform );\r\n\r\n\t\t\t\tpaths.push( path );\r\n\r\n\t\t\t\tpath.userData = { node: node, style: style };\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst childNodes = node.childNodes;\r\n\r\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\r\n\r\n\t\t\t\tconst node = childNodes[ i ];\r\n\r\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\r\n\r\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\r\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\r\n\t\t\t\t\t// <style/> there.\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tparseNode( node, style );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( transform ) {\r\n\r\n\t\t\t\ttransformStack.pop();\r\n\r\n\t\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePathNode( node ) {\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tconst point = new Vector2();\r\n\t\t\tconst control = new Vector2();\r\n\r\n\t\t\tconst firstPoint = new Vector2();\r\n\t\t\tlet isFirstPoint = true;\r\n\t\t\tlet doSetFirstPoint = false;\r\n\r\n\t\t\tconst d = node.getAttribute( 'd' );\r\n\r\n\t\t\t// console.log( d );\r\n\r\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\r\n\r\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst command = commands[ i ];\r\n\r\n\t\t\t\tconst type = command.charAt( 0 );\r\n\t\t\t\tconst data = command.slice( 1 ).trim();\r\n\r\n\t\t\t\tif ( isFirstPoint === true ) {\r\n\r\n\t\t\t\t\tdoSetFirstPoint = true;\r\n\t\t\t\t\tisFirstPoint = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet numbers;\r\n\r\n\t\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\t\tcase 'M':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'H':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'V':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'L':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'C':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'S':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'T':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'A':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if start point == end point\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'm':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) {\r\n\r\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'h':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'v':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'l':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'c':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 's':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\r\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'q':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 't':\r\n\t\t\t\t\t\tnumbers = parseFloats( data );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\r\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\r\n\t\t\t\t\t\t\t\trx,\r\n\t\t\t\t\t\t\t\try,\r\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\r\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\tcontrol.x = rx;\r\n\t\t\t\t\t\t\tcontrol.y = ry;\r\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\r\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'a':\r\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\r\n\r\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\r\n\r\n\t\t\t\t\t\t\t// skip command if no displacement\r\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tconst start = point.clone();\r\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\r\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\r\n\t\t\t\t\t\t\tcontrol.x = point.x;\r\n\t\t\t\t\t\t\tcontrol.y = point.y;\r\n\t\t\t\t\t\t\tparseArcCommand(\r\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Z':\r\n\t\t\t\t\tcase 'z':\r\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t// Reset point to beginning of Path\r\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\r\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\r\n\t\t\t\t\t\t\tisFirstPoint = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.warn( command );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\r\n\r\n\t\t\t\tdoSetFirstPoint = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCSSStylesheet( node ) {\r\n\r\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\r\n\r\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\r\n\r\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\r\n\r\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\r\n\r\n\t\t\t\tconst selectorList = stylesheet.selectorText\r\n\t\t\t\t\t.split( /,/gm )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\r\n\r\n\t\t\t\t\t// Remove empty rules\r\n\t\t\t\t\tconst definitions = Object.fromEntries(\r\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\r\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\r\n\t\t\t\t\t\tdefinitions\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\r\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\r\n\t\t * From\r\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n\t\t * To\r\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\r\n\t\t */\r\n\r\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\r\n\r\n\t\t\tif ( rx == 0 || ry == 0 ) {\r\n\r\n\t\t\t\t// draw a line if either of the radii == 0\r\n\t\t\t\tpath.lineTo( end.x, end.y );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\r\n\r\n\t\t\t// Ensure radii are positive\r\n\t\t\trx = Math.abs( rx );\r\n\t\t\try = Math.abs( ry );\r\n\r\n\t\t\t// Compute (x1', y1')\r\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\r\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\r\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\r\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\r\n\r\n\t\t\t// Compute (cx', cy')\r\n\t\t\tlet rxs = rx * rx;\r\n\t\t\tlet rys = ry * ry;\r\n\t\t\tconst x1ps = x1p * x1p;\r\n\t\t\tconst y1ps = y1p * y1p;\r\n\r\n\t\t\t// Ensure radii are large enough\r\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\r\n\r\n\t\t\tif ( cr > 1 ) {\r\n\r\n\t\t\t\t// scale up rx,ry equally so cr == 1\r\n\t\t\t\tconst s = Math.sqrt( cr );\r\n\t\t\t\trx = s * rx;\r\n\t\t\t\try = s * ry;\r\n\t\t\t\trxs = rx * rx;\r\n\t\t\t\trys = ry * ry;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\r\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\r\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\r\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\r\n\t\t\tconst cxp = q * rx * y1p / ry;\r\n\t\t\tconst cyp = - q * ry * x1p / rx;\r\n\r\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\r\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\r\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\r\n\r\n\t\t\t// Step 4: Compute θ1 and Δθ\r\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\r\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\r\n\r\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\r\n\r\n\t\t}\r\n\r\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\r\n\r\n\t\t\tconst dot = ux * vx + uy * vy;\r\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\r\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\r\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\r\n\t\t\treturn ang;\r\n\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\r\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\r\n\t\t*/\r\n\t\tfunction parseRectNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\r\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\r\n\r\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\r\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\r\n\t\t\tconst bci = 1 - 0.551915024494;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\t// top left\r\n\t\t\tpath.moveTo( x + rx, y );\r\n\r\n\t\t\t// top right\r\n\t\t\tpath.lineTo( x + w - rx, y );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry * bci,\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom right\r\n\t\t\tpath.lineTo( x + w, y + h - ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + w,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx + w - rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx + w - rx,\r\n\t\t\t\t\ty + h\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// bottom left\r\n\t\t\tpath.lineTo( x + rx, y + h );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo(\r\n\t\t\t\t\tx + rx * bci,\r\n\t\t\t\t\ty + h,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry * bci,\r\n\t\t\t\t\tx,\r\n\t\t\t\t\ty + h - ry\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// back to top left\r\n\t\t\tpath.lineTo( x, y + ry );\r\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\r\n\r\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolygonNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = true;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parsePolylineNode( node ) {\r\n\r\n\t\t\tfunction iterator( match, a, b ) {\r\n\r\n\t\t\t\tconst x = parseFloatWithUnits( a );\r\n\t\t\t\tconst y = parseFloatWithUnits( b );\r\n\r\n\t\t\t\tif ( index === 0 ) {\r\n\r\n\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst regex = /([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)(?:,|\\s)([+-]?\\d*\\.?\\d+(?:e[+-]?\\d+)?)/g;\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\r\n\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseCircleNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\r\n\r\n\t\t\tconst subpath = new Path();\r\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseEllipseNode( node ) {\r\n\r\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\r\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\r\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\r\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\r\n\r\n\t\t\tconst subpath = new Path();\r\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.subPaths.push( subpath );\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseLineNode( node ) {\r\n\r\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\r\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\r\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\r\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\r\n\r\n\t\t\tconst path = new ShapePath();\r\n\t\t\tpath.moveTo( x1, y1 );\r\n\t\t\tpath.lineTo( x2, y2 );\r\n\t\t\tpath.currentPath.autoClose = false;\r\n\r\n\t\t\treturn path;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction parseStyle( node, style ) {\r\n\r\n\t\t\tstyle = Object.assign( {}, style ); // clone style\r\n\r\n\t\t\tlet stylesheetStyles = {};\r\n\r\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\r\n\r\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\r\n\t\t\t\t\t.split( /\\s/ )\r\n\t\t\t\t\t.filter( Boolean )\r\n\t\t\t\t\t.map( i => i.trim() );\r\n\r\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\r\n\r\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\r\n\r\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\r\n\r\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\r\n\r\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\r\n\r\n\t\t\t\t\treturn v;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\r\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\r\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction clamp( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction positive( v ) {\r\n\r\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddStyle( 'fill', 'fill' );\r\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\r\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\r\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\r\n\t\t\taddStyle( 'stroke', 'stroke' );\r\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\r\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\r\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\r\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\r\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\r\n\t\t\taddStyle( 'visibility', 'visibility' );\r\n\r\n\t\t\treturn style;\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\r\n\r\n\t\tfunction getReflection( a, b ) {\r\n\r\n\t\t\treturn a - ( b - a );\r\n\r\n\t\t}\r\n\r\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\r\n\r\n\t\tfunction parseFloats( input, flags, stride ) {\r\n\r\n\t\t\tif ( typeof input !== 'string' ) {\r\n\r\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Character groups\r\n\t\t\tconst RE = {\r\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\r\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\r\n\t\t\t\tDIGIT: /[\\d]/,\r\n\t\t\t\tSIGN: /[-+]/,\r\n\t\t\t\tPOINT: /\\./,\r\n\t\t\t\tCOMMA: /,/,\r\n\t\t\t\tEXP: /e/i,\r\n\t\t\t\tFLAGS: /[01]/\r\n\t\t\t};\r\n\r\n\t\t\t// States\r\n\t\t\tconst SEP = 0;\r\n\t\t\tconst INT = 1;\r\n\t\t\tconst FLOAT = 2;\r\n\t\t\tconst EXP = 3;\r\n\r\n\t\t\tlet state = SEP;\r\n\t\t\tlet seenComma = true;\r\n\t\t\tlet number = '', exponent = '';\r\n\t\t\tconst result = [];\r\n\r\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\r\n\r\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\r\n\t\t\t\terror.partial = partial;\r\n\t\t\t\tthrow error;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction newNumber() {\r\n\r\n\t\t\t\tif ( number !== '' ) {\r\n\r\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\r\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnumber = '';\r\n\t\t\t\texponent = '';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet current;\r\n\t\t\tconst length = input.length;\r\n\r\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tcurrent = input[ i ];\r\n\r\n\t\t\t\t// check for flags\r\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\r\n\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse until next number\r\n\t\t\t\tif ( state === SEP ) {\r\n\r\n\t\t\t\t\t// eat whitespace\r\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// start new number\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = INT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tnumber = current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\r\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( seenComma ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse integer part\r\n\t\t\t\tif ( state === INT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\r\n\t\t\t\t\tif ( RE.SIGN.test( current )\r\n\t\t\t\t\t\t\t&& number.length === 1\r\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse decimal part\r\n\t\t\t\tif ( state === FLOAT ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\tnumber += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\r\n\r\n\t\t\t\t\t\tstate = EXP;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\r\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\r\n\r\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// parse exponent part\r\n\t\t\t\tif ( state === EXP ) {\r\n\r\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\r\n\r\n\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\t\tif ( exponent === '' ) {\r\n\r\n\t\t\t\t\t\t\texponent += current;\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\r\n\r\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// end of number\r\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = false;\r\n\r\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = SEP;\r\n\t\t\t\t\tseenComma = true;\r\n\r\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = INT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\r\n\r\n\t\t\t\t\tnewNumber();\r\n\t\t\t\t\tstate = FLOAT;\r\n\t\t\t\t\tnumber = current;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrowSyntaxError( current, i, result );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// add the last number found (if any)\r\n\t\t\tnewNumber();\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t\t// Units\r\n\r\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\r\n\r\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\r\n\t\tconst unitConversion = {\r\n\r\n\t\t\t'mm': {\r\n\t\t\t\t'mm': 1,\r\n\t\t\t\t'cm': 0.1,\r\n\t\t\t\t'in': 1 / 25.4,\r\n\t\t\t\t'pt': 72 / 25.4,\r\n\t\t\t\t'pc': 6 / 25.4,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'cm': {\r\n\t\t\t\t'mm': 10,\r\n\t\t\t\t'cm': 1,\r\n\t\t\t\t'in': 1 / 2.54,\r\n\t\t\t\t'pt': 72 / 2.54,\r\n\t\t\t\t'pc': 6 / 2.54,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'in': {\r\n\t\t\t\t'mm': 25.4,\r\n\t\t\t\t'cm': 2.54,\r\n\t\t\t\t'in': 1,\r\n\t\t\t\t'pt': 72,\r\n\t\t\t\t'pc': 6,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pt': {\r\n\t\t\t\t'mm': 25.4 / 72,\r\n\t\t\t\t'cm': 2.54 / 72,\r\n\t\t\t\t'in': 1 / 72,\r\n\t\t\t\t'pt': 1,\r\n\t\t\t\t'pc': 6 / 72,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'pc': {\r\n\t\t\t\t'mm': 25.4 / 6,\r\n\t\t\t\t'cm': 2.54 / 6,\r\n\t\t\t\t'in': 1 / 6,\r\n\t\t\t\t'pt': 72 / 6,\r\n\t\t\t\t'pc': 1,\r\n\t\t\t\t'px': - 1\r\n\t\t\t},\r\n\t\t\t'px': {\r\n\t\t\t\t'px': 1\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseFloatWithUnits( string ) {\r\n\r\n\t\t\tlet theUnit = 'px';\r\n\r\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\r\n\r\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\r\n\r\n\t\t\t\t\tconst u = units[ i ];\r\n\r\n\t\t\t\t\tif ( string.endsWith( u ) ) {\r\n\r\n\t\t\t\t\t\ttheUnit = u;\r\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet scale = undefined;\r\n\r\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\r\n\r\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\r\n\r\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\r\n\r\n\t\t\t\tif ( scale < 0 ) {\r\n\r\n\t\t\t\t\t// Conversion scale to pixels\r\n\r\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn scale * parseFloat( string );\r\n\r\n\t\t}\r\n\r\n\t\t// Transforms\r\n\r\n\t\tfunction getNodeTransform( node ) {\r\n\r\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst transform = parseNodeTransform( node );\r\n\r\n\t\t\tif ( transformStack.length > 0 ) {\r\n\r\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentTransform.copy( transform );\r\n\t\t\ttransformStack.push( transform );\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseNodeTransform( node ) {\r\n\r\n\t\t\tconst transform = new Matrix3();\r\n\t\t\tconst currentTransform = tempTransform0;\r\n\r\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\r\n\r\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\r\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\r\n\r\n\t\t\t\ttransform.translate( tx, ty );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\r\n\r\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\r\n\r\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\r\n\r\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\r\n\r\n\t\t\t\t\tif ( transformText === '' ) continue;\r\n\r\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\r\n\t\t\t\t\tconst closeParPos = transformText.length;\r\n\r\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\r\n\r\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\r\n\r\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\r\n\r\n\t\t\t\t\t\tcurrentTransform.identity();\r\n\r\n\t\t\t\t\t\tswitch ( transformType ) {\r\n\r\n\t\t\t\t\t\t\tcase 'translate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet ty = 0;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'rotate':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tlet angle = 0;\r\n\t\t\t\t\t\t\t\t\tlet cx = 0;\r\n\t\t\t\t\t\t\t\t\tlet cy = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t// Angle\r\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Center x, y\r\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\r\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\r\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\r\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\r\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'scale':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\r\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\r\n\r\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewX':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'skewY':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\r\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'matrix':\r\n\r\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\r\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\r\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\r\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttransform.premultiply( currentTransform );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn transform;\r\n\r\n\t\t}\r\n\r\n\t\tfunction transformPath( path, m ) {\r\n\r\n\t\t\tfunction transfVec2( v2 ) {\r\n\r\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\r\n\r\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseGeneric( curve ) {\r\n\r\n\t\t\t\t// For math description see:\r\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\r\n\r\n\t\t\t\tconst a = curve.xRadius;\r\n\t\t\t\tconst b = curve.yRadius;\r\n\r\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\r\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\r\n\r\n\t\t\t\tconst v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );\r\n\t\t\t\tconst v2 = new Vector3( - b * sinTheta, b * cosTheta, 0 );\r\n\r\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\r\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\r\n\r\n\t\t\t\tconst mF = tempTransform0.set(\r\n\t\t\t\t\tf1.x, f2.x, 0,\r\n\t\t\t\t\tf1.y, f2.y, 0,\r\n\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t);\r\n\r\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\r\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\r\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\r\n\t\t\t\tconst mQe = mQ.elements;\r\n\r\n\t\t\t\tconst ed = eigenDecomposition( mQe[ 0 ], mQe[ 1 ], mQe[ 4 ] );\r\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\r\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\r\n\r\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\r\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\r\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\r\n\r\n\t\t\t\tconst isFullEllipse =\r\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\r\n\r\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\r\n\t\t\t\t// would converge to a sinle value effectively removing the whole curve\r\n\r\n\t\t\t\tif ( ! isFullEllipse ) {\r\n\r\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\r\n\t\t\t\t\t\trt1sqrt, 0, 0,\r\n\t\t\t\t\t\t0, rt2sqrt, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mRT = tempTransform2.set(\r\n\t\t\t\t\t\ted.cs, ed.sn, 0,\r\n\t\t\t\t\t\t- ed.sn, ed.cs, 0,\r\n\t\t\t\t\t\t0, 0, 1,\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\r\n\r\n\t\t\t\t\tconst transformAngle = phi => {\r\n\r\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\r\n\t\t\t\t\t\t\tnew Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\r\n\r\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\r\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\r\n\r\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction transfEllipseNoSkew( curve ) {\r\n\r\n\t\t\t\t// Faster shortcut if no skew is applied\r\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\r\n\r\n\t\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\t\tcurve.xRadius *= sx;\r\n\t\t\t\tcurve.yRadius *= sy;\r\n\r\n\t\t\t\t// Extract rotation angle from the matrix of form:\r\n\t\t\t\t//\r\n\t\t\t\t//  | cosθ sx   -sinθ sy |\r\n\t\t\t\t//  | sinθ sx    cosθ sy |\r\n\t\t\t\t//\r\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\r\n\t\t\t\t// `sx`, `sy`, or both might be zero.\r\n\t\t\t\tconst theta =\r\n\t\t\t\t\tsx > Number.EPSILON\r\n\t\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\r\n\t\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\r\n\r\n\t\t\t\tcurve.aRotation += theta;\r\n\r\n\t\t\t\tif ( isTransformFlipped( m ) ) {\r\n\r\n\t\t\t\t\tcurve.aStartAngle *= - 1;\r\n\t\t\t\t\tcurve.aEndAngle *= - 1;\r\n\t\t\t\t\tcurve.aClockwise = ! curve.aClockwise;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst subPaths = path.subPaths;\r\n\r\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\r\n\r\n\t\t\t\tconst subPath = subPaths[ i ];\r\n\t\t\t\tconst curves = subPath.curves;\r\n\r\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\r\n\r\n\t\t\t\t\tconst curve = curves[ j ];\r\n\r\n\t\t\t\t\tif ( curve.isLineCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\t\t\t\t\t\ttransfVec2( curve.v3 );\r\n\r\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\r\n\r\n\t\t\t\t\t\ttransfVec2( curve.v0 );\r\n\t\t\t\t\t\ttransfVec2( curve.v1 );\r\n\t\t\t\t\t\ttransfVec2( curve.v2 );\r\n\r\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\r\n\r\n\t\t\t\t\t\t// Transform ellipse center point\r\n\r\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\r\n\t\t\t\t\t\ttransfVec2( tempV2 );\r\n\t\t\t\t\t\tcurve.aX = tempV2.x;\r\n\t\t\t\t\t\tcurve.aY = tempV2.y;\r\n\r\n\t\t\t\t\t\t// Transform ellipse shape parameters\r\n\r\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformFlipped( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isTransformSkewed( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\r\n\r\n\t\t\t// Shortcut for trivial rotations and transformations\r\n\t\t\tif ( basisDot === 0 ) return false;\r\n\r\n\t\t\tconst sx = getTransformScaleX( m );\r\n\t\t\tconst sy = getTransformScaleY( m );\r\n\r\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleX( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getTransformScaleY( m ) {\r\n\r\n\t\t\tconst te = m.elements;\r\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\r\n\r\n\t\t}\r\n\r\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\r\n\t\t//    [ A  B ]\r\n\t\t//    [ B  C ]\r\n\t\t// in the form\r\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\r\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\r\n\t\t// where rt1 >= rt2.\r\n\t\t//\r\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\r\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\r\n\t\tfunction eigenDecomposition( A, B, C ) {\r\n\r\n\t\t\tlet rt1, rt2, cs, sn, t;\r\n\t\t\tconst sm = A + C;\r\n\t\t\tconst df = A - C;\r\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\r\n\r\n\t\t\tif ( sm > 0 ) {\r\n\r\n\t\t\t\trt1 = 0.5 * ( sm + rt );\r\n\t\t\t\tt = 1 / rt1;\r\n\t\t\t\trt2 = A * t * C - B * t * B;\r\n\r\n\t\t\t} else if ( sm < 0 ) {\r\n\r\n\t\t\t\trt2 = 0.5 * ( sm - rt );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\r\n\r\n\t\t\t\trt1 = 0.5 * rt;\r\n\t\t\t\trt2 = - 0.5 * rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Calculate eigenvectors\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tcs = df + rt;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcs = df - rt;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\r\n\r\n\t\t\t\tt = - 2 * B / cs;\r\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tcs = t * sn;\r\n\r\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\r\n\r\n\t\t\t\tcs = 1;\r\n\t\t\t\tsn = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = - 0.5 * cs / B;\r\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\r\n\t\t\t\tsn = t * cs;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( df > 0 ) {\r\n\r\n\t\t\t\tt = cs;\r\n\t\t\t\tcs = - sn;\r\n\t\t\t\tsn = t;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { rt1, rt2, cs, sn };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst paths = [];\r\n\t\tconst stylesheets = {};\r\n\r\n\t\tconst transformStack = [];\r\n\r\n\t\tconst tempTransform0 = new Matrix3();\r\n\t\tconst tempTransform1 = new Matrix3();\r\n\t\tconst tempTransform2 = new Matrix3();\r\n\t\tconst tempTransform3 = new Matrix3();\r\n\t\tconst tempV2 = new Vector2();\r\n\t\tconst tempV3 = new Vector3();\r\n\r\n\t\tconst currentTransform = new Matrix3();\r\n\r\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\r\n\r\n\t\tparseNode( xml.documentElement, {\r\n\t\t\tfill: '#000',\r\n\t\t\tfillOpacity: 1,\r\n\t\t\tstrokeOpacity: 1,\r\n\t\t\tstrokeWidth: 1,\r\n\t\t\tstrokeLineJoin: 'miter',\r\n\t\t\tstrokeLineCap: 'butt',\r\n\t\t\tstrokeMiterLimit: 4\r\n\t\t} );\r\n\r\n\t\tconst data = { paths: paths, xml: xml.documentElement };\r\n\r\n\t\t// console.log( paths );\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n\tstatic createShapes( shapePath ) {\r\n\r\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\r\n\t\t// Returns Shape object\r\n\r\n\t\tconst BIGNUMBER = 999999999;\r\n\r\n\t\tconst IntersectionLocationType = {\r\n\t\t\tORIGIN: 0,\r\n\t\t\tDESTINATION: 1,\r\n\t\t\tBETWEEN: 2,\r\n\t\t\tLEFT: 3,\r\n\t\t\tRIGHT: 4,\r\n\t\t\tBEHIND: 5,\r\n\t\t\tBEYOND: 6\r\n\t\t};\r\n\r\n\t\tconst classifyResult = {\r\n\t\t\tloc: IntersectionLocationType.ORIGIN,\r\n\t\t\tt: 0\r\n\t\t};\r\n\r\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\r\n\r\n\t\t\tconst x1 = a0.x;\r\n\t\t\tconst x2 = a1.x;\r\n\t\t\tconst x3 = b0.x;\r\n\t\t\tconst x4 = b1.x;\r\n\t\t\tconst y1 = a0.y;\r\n\t\t\tconst y2 = a1.y;\r\n\t\t\tconst y3 = b0.y;\r\n\t\t\tconst y4 = b1.y;\r\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\r\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\r\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\r\n\t\t\tconst t1 = nom1 / denom;\r\n\t\t\tconst t2 = nom2 / denom;\r\n\r\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\r\n\r\n\t\t\t\t//1. lines are parallel or edges don't intersect\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\r\n\r\n\t\t\t\t//2. lines are colinear\r\n\r\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\t\t\t\t\t//find position of this endpoints relatively to edge1\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\r\n\r\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//3. edges intersect\r\n\r\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\r\n\r\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\r\n\r\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\r\n\r\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\r\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\r\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\r\n\t\t\t\treturn { x: x, y: y, t: t1 };\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\r\n\r\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\r\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\r\n\t\t\tconst bx = p.x - edgeStart.x;\r\n\t\t\tconst by = p.y - edgeStart.y;\r\n\t\t\tconst sa = ax * by - bx * ay;\r\n\r\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\r\n\t\t\t\tclassifyResult.t = 0;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\r\n\t\t\t\tclassifyResult.t = 1;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa < - Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( sa > Number.EPSILON ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\r\n\t\t\t\treturn;\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\r\n\r\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet t;\r\n\r\n\t\t\tif ( ax !== 0 ) {\r\n\r\n\t\t\t\tt = bx / ax;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tt = by / ay;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\r\n\t\t\tclassifyResult.t = t;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getIntersections( path1, path2 ) {\r\n\r\n\t\t\tconst intersectionsRaw = [];\r\n\t\t\tconst intersections = [];\r\n\r\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\r\n\r\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\r\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\r\n\r\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\r\n\r\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\r\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\r\n\r\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\r\n\r\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\r\n\r\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\r\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn intersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\r\n\r\n\t\t\tconst center = new Vector2();\r\n\t\t\tboundingBox.getCenter( center );\r\n\r\n\t\t\tconst allIntersections = [];\r\n\r\n\t\t\tpaths.forEach( path => {\r\n\r\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\r\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\r\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\r\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\r\n\r\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\r\n\r\n\t\t\t\t\tintersections.forEach( p => {\r\n\r\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn allIntersections;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\r\n\r\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\r\n\r\n\t\t\t\t_fillRule = 'nonzero';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst centerBoundingBox = new Vector2();\r\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\r\n\r\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\r\n\r\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\r\n\r\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\r\n\r\n\t\t\t\treturn i1.point.x - i2.point.x;\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst baseIntersections = [];\r\n\t\t\tconst otherIntersections = [];\r\n\r\n\t\t\tscanlineIntersections.forEach( i => {\r\n\r\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\r\n\r\n\t\t\t\t\tbaseIntersections.push( i );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\totherIntersections.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\r\n\r\n\t\t\t// build up the path hierarchy\r\n\t\t\tconst stack = [];\r\n\t\t\tlet i = 0;\r\n\r\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\r\n\r\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\r\n\r\n\t\t\t\t\tstack.pop();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstack.push( simplePath.identifier );\r\n\r\n\t\t\tif ( _fillRule === 'evenodd' ) {\r\n\r\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\r\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\r\n\r\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\r\n\t\t\t\tlet isHole = true;\r\n\t\t\t\tlet isHoleFor = null;\r\n\t\t\t\tlet lastCWValue = null;\r\n\r\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\r\n\r\n\t\t\t\t\tconst identifier = stack[ i ];\r\n\t\t\t\t\tif ( isHole ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = false;\r\n\t\t\t\t\t\tisHoleFor = identifier;\r\n\r\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\r\n\r\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\r\n\t\t\t\t\t\tisHole = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check for self intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// check intersecting paths\r\n\t\t// TODO\r\n\r\n\t\t// prepare paths for hole detection\r\n\t\tlet scanlineMinX = BIGNUMBER;\r\n\t\tlet scanlineMaxX = - BIGNUMBER;\r\n\r\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\r\n\r\n\t\t\tconst points = p.getPoints();\r\n\t\t\tlet maxY = - BIGNUMBER;\r\n\t\t\tlet minY = BIGNUMBER;\r\n\t\t\tlet maxX = - BIGNUMBER;\r\n\t\t\tlet minX = BIGNUMBER;\r\n\r\n\t      \t//points.forEach(p => p.y *= -1);\r\n\r\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\r\n\r\n\t\t\t\tconst p = points[ i ];\r\n\r\n\t\t\t\tif ( p.y > maxY ) {\r\n\r\n\t\t\t\t\tmaxY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.y < minY ) {\r\n\r\n\t\t\t\t\tminY = p.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x > maxX ) {\r\n\r\n\t\t\t\t\tmaxX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p.x < minX ) {\r\n\r\n\t\t\t\t\tminX = p.x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\t\t\tif ( scanlineMaxX <= maxX ) {\r\n\r\n\t\t\t\tscanlineMaxX = maxX + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( scanlineMinX >= minX ) {\r\n\r\n\t\t\t\tscanlineMinX = minX - 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: - 1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\r\n\r\n\t\t} );\r\n\r\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\r\n\r\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier ++ ) {\r\n\r\n\t\t\tsimplePaths[ identifier ].identifier = identifier;\r\n\r\n\t\t}\r\n\r\n\t\t// check if path is solid or a hole\r\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, ( shapePath.userData ? shapePath.userData.style.fillRule : undefined ) ) );\r\n\r\n\r\n\t\tconst shapesToReturn = [];\r\n\t\tsimplePaths.forEach( p => {\r\n\r\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\r\n\r\n\t\t\tif ( ! amIAHole.isHole ) {\r\n\r\n\t\t\t\tconst shape = new Shape();\r\n\t\t\t\tshape.curves = p.curves;\r\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\r\n\t\t\t\tholes.forEach( h => {\r\n\r\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\r\n\t\t\t\t\tconst path = new Path();\r\n\t\t\t\t\tpath.curves = hole.curves;\r\n\t\t\t\t\tshape.holes.push( path );\r\n\r\n\t\t\t\t} );\r\n\t\t\t\tshapesToReturn.push( shape );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn shapesToReturn;\r\n\r\n\t}\r\n\r\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\r\n\r\n\t\t// Param width: Stroke width\r\n\t\t// Param color: As returned by THREE.Color.getStyle()\r\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\r\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\r\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\r\n\t\t// Returns style object\r\n\r\n\t\twidth = width !== undefined ? width : 1;\r\n\t\tcolor = color !== undefined ? color : '#000';\r\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\r\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\r\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\r\n\r\n\t\treturn {\r\n\t\t\tstrokeColor: color,\r\n\t\t\tstrokeWidth: width,\r\n\t\t\tstrokeLineJoin: lineJoin,\r\n\t\t\tstrokeLineCap: lineCap,\r\n\t\t\tstrokeMiterLimit: miterLimit\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\r\n\r\n\t\t// Generates a stroke with some witdh around the given path.\r\n\t\t// The path can be open or closed (last point equals to first point)\r\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\r\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\r\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\r\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\r\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\r\n\r\n\t\tconst vertices = [];\r\n\t\tconst normals = [];\r\n\t\tconst uvs = [];\r\n\r\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = new BufferGeometry();\r\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\r\n\r\n\t\t// This function can be called to update existing arrays or buffers.\r\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\r\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\r\n\t\t// Returns number of written vertices / normals / uvs pairs\r\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\r\n\t\t// 'normals' and 'uvs' buffers are optional\r\n\r\n\t\tconst tempV2_1 = new Vector2();\r\n\t\tconst tempV2_2 = new Vector2();\r\n\t\tconst tempV2_3 = new Vector2();\r\n\t\tconst tempV2_4 = new Vector2();\r\n\t\tconst tempV2_5 = new Vector2();\r\n\t\tconst tempV2_6 = new Vector2();\r\n\t\tconst tempV2_7 = new Vector2();\r\n\t\tconst lastPointL = new Vector2();\r\n\t\tconst lastPointR = new Vector2();\r\n\t\tconst point0L = new Vector2();\r\n\t\tconst point0R = new Vector2();\r\n\t\tconst currentPointL = new Vector2();\r\n\t\tconst currentPointR = new Vector2();\r\n\t\tconst nextPointL = new Vector2();\r\n\t\tconst nextPointR = new Vector2();\r\n\t\tconst innerPoint = new Vector2();\r\n\t\tconst outerPoint = new Vector2();\r\n\r\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\r\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\r\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\r\n\r\n\t\t// First ensure there are no duplicated points\r\n\t\tpoints = removeDuplicatedPoints( points );\r\n\r\n\t\tconst numPoints = points.length;\r\n\r\n\t\tif ( numPoints < 2 ) return 0;\r\n\r\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\r\n\r\n\t\tlet currentPoint;\r\n\t\tlet previousPoint = points[ 0 ];\r\n\t\tlet nextPoint;\r\n\r\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\r\n\r\n\t\tconst deltaU = 1 / ( numPoints - 1 );\r\n\t\tlet u0 = 0, u1;\r\n\r\n\t\tlet innerSideModified;\r\n\t\tlet joinIsOnLeftSide;\r\n\t\tlet isMiter;\r\n\t\tlet initialJoinIsOnLeftSide = false;\r\n\r\n\t\tlet numVertices = 0;\r\n\t\tlet currentCoordinate = vertexOffset * 3;\r\n\t\tlet currentCoordinateUV = vertexOffset * 2;\r\n\r\n\t\t// Get initial left and right stroke points\r\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\r\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\r\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\r\n\t\tpoint0L.copy( lastPointL );\r\n\t\tpoint0R.copy( lastPointR );\r\n\r\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\r\n\r\n\t\t\tcurrentPoint = points[ iPoint ];\r\n\r\n\t\t\t// Get next point\r\n\t\t\tif ( iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\tif ( isClosed ) {\r\n\r\n\t\t\t\t\t// Skip duplicated initial point\r\n\t\t\t\t\tnextPoint = points[ 1 ];\r\n\r\n\t\t\t\t} else nextPoint = undefined;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Normal of previous segment in tempV2_1\r\n\t\t\tconst normal1 = tempV2_1;\r\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\r\n\r\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\r\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\tu1 = u0 + deltaU;\r\n\r\n\t\t\tinnerSideModified = false;\r\n\r\n\t\t\tif ( nextPoint !== undefined ) {\r\n\r\n\t\t\t\t// Normal of next segment in tempV2_2\r\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\r\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\r\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\r\n\r\n\t\t\t\tjoinIsOnLeftSide = true;\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\r\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\r\n\r\n\t\t\t\t\tjoinIsOnLeftSide = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\r\n\r\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\r\n\t\t\t\ttempV2_3.normalize();\r\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\r\n\r\n\t\t\t\t// If path is straight, don't create join\r\n\t\t\t\tif ( dot > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// Compute inner and outer segment intersections\r\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\r\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\r\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\r\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\r\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\r\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\r\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\r\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\r\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\r\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\r\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\r\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\r\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\r\n\r\n\t\t\t\t\t\tinnerSideModified = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\r\n\t\t\t\t\tinnerPoint.add( currentPoint );\r\n\r\n\t\t\t\t\tisMiter = false;\r\n\r\n\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\r\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\r\n\r\n\t\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\r\n\r\n\t\t\t\t\t\tcase 'bevel':\r\n\r\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t// Join triangles\r\n\r\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'miter':\r\n\t\t\t\t\t\tcase 'miter-clip':\r\n\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\r\n\r\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\r\n\r\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Segment triangles\r\n\r\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\r\n\r\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\r\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t// Miter join segment triangles\r\n\r\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\r\n\r\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\r\n\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\r\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tisMiter = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\r\n\r\n\t\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\r\n\r\n\t\t\t\tmakeSegmentTriangles();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\r\n\r\n\t\t\t\t// Start line endcap\r\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Increment loop variables\r\n\r\n\t\t\tu0 = u1;\r\n\r\n\t\t\tpreviousPoint = currentPoint;\r\n\r\n\t\t\tlastPointL.copy( nextPointL );\r\n\t\t\tlastPointR.copy( nextPointR );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! isClosed ) {\r\n\r\n\t\t\t// Ending line endcap\r\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\r\n\r\n\t\t} else if ( innerSideModified && vertices ) {\r\n\r\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\r\n\r\n\t\t\tlet lastOuter = outerPoint;\r\n\t\t\tlet lastInner = innerPoint;\r\n\r\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tlastOuter = innerPoint;\r\n\t\t\t\tlastInner = outerPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\tif ( isMiter ) {\r\n\r\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn numVertices;\r\n\r\n\t\t// -- End of algorithm\r\n\r\n\t\t// -- Functions\r\n\r\n\t\tfunction getNormal( p1, p2, result ) {\r\n\r\n\t\t\tresult.subVectors( p2, p1 );\r\n\t\t\treturn result.set( - result.y, result.x ).normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfunction addVertex( position, u, v ) {\r\n\r\n\t\t\tif ( vertices ) {\r\n\r\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\r\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\r\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\r\n\r\n\t\t\t\tif ( normals ) {\r\n\r\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\r\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcurrentCoordinate += 3;\r\n\r\n\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\r\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\r\n\r\n\t\t\t\t\tcurrentCoordinateUV += 2;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnumVertices += 3;\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\r\n\r\n\t\t\t// param p1, p2: Points in the circle arc.\r\n\t\t\t// p1 and p2 are in clockwise direction.\r\n\r\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\r\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\r\n\r\n\t\t\tlet angle = Math.PI;\r\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\r\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\r\n\r\n\t\t\tangle /= arcDivisions;\r\n\r\n\t\t\ttempV2_3.copy( p1 );\r\n\r\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\r\n\r\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\r\n\r\n\t\t\t\taddVertex( tempV2_3, u, v );\r\n\t\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t\t\ttempV2_3.copy( tempV2_4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\taddVertex( tempV2_4, u, v );\r\n\t\t\taddVertex( p2, u, v );\r\n\t\t\taddVertex( center, u, 0.5 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentTriangles() {\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\taddVertex( currentPointL, u1, 1 );\r\n\t\t\taddVertex( currentPointR, u1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\t// Optimized segment + bevel triangles\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Path segments triangles\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\t// Bevel join triangle\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\r\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\r\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\r\n\r\n\t\t\tif ( innerSideModified ) {\r\n\r\n\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\r\n\r\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\r\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\r\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\r\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\r\n\r\n\t\t\t// param center: End point of the path\r\n\t\t\t// param p1, p2: Left and right cap points\r\n\r\n\t\t\tswitch ( style.strokeLineCap ) {\r\n\r\n\t\t\t\tcase 'round':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'square':\r\n\r\n\t\t\t\t\tif ( start ) {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\r\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\r\n\r\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\r\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\r\n\r\n\t\t\t\t\t\tconst vl = vertices.length;\r\n\r\n\t\t\t\t\t\t// Modify already existing vertices\r\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\r\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'butt':\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t// Nothing to do here\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction removeDuplicatedPoints( points ) {\r\n\r\n\t\t\t// Creates a new array if necessary with duplicated points removed.\r\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\r\n\r\n\t\t\tlet dupPoints = false;\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\r\n\r\n\t\t\t\t\tdupPoints = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! dupPoints ) return points;\r\n\r\n\t\t\tconst newPoints = [];\r\n\t\t\tnewPoints.push( points[ 0 ] );\r\n\r\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\r\n\r\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\r\n\r\n\t\t\t\t\tnewPoints.push( points[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\r\n\r\n\t\t\treturn newPoints;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport { SVGLoader };\r\n"],"names":["SVGLoader","_Loader","_inherits","_super","_createSuper","manager","_this","_classCallCheck","call","defaultDPI","defaultUnit","_createClass","key","value","url","onLoad","onProgress","onError","scope","this","loader","FileLoader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","lineTo","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","input","flags","stride","TypeError","current","RE","SEPARATOR","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","state","seenComma","number","exponent","result","throwSyntaxError","partial","SyntaxError","newNumber","push","Number","pow","Array","isArray","includes","test","units","unitConversion","string","theUnit","String","n","u","endsWith","substring","scale","parseFloat","isTransformFlipped","m","te","elements","isTransformSkewed","basisDot","sx","getTransformScaleX","sy","getTransformScaleY","EPSILON","paths","transformStack","tempTransform0","Matrix3","tempTransform1","tempTransform2","tempTransform3","tempV2","Vector2","tempV3","Vector3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","nodeName","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","slice","array","identity","angle","makeTranslation","makeRotation","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","getNodeTransform","isDefsNode","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","definitions","fromEntries","entries","_ref","_slicedToArray","parseCSSStylesheet","ShapePath","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","charAt","data","numbers","jl","moveTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","parsePathNode","w","h","bci","parseRectNode","iterator","index","regex","replace","parsePolygonNode","parsePolylineNode","r","subpath","Path","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","usedNodeId","getAttributeNS","usedNode","viewportElement","getElementById","fill","color","setStyle","transfVec2","v2","applyMatrix3","transfEllipseGeneric","curve","xRadius","yRadius","cosTheta","aRotation","sinTheta","v1","f1","f2","mF","mFInv","invert","mQe","transpose","multiply","ed","A","B","C","rt1","rt2","cs","sn","t","sm","df","rt","eigenDecomposition","rt1sqrt","rt2sqrt","atan2","aEndAngle","aStartAngle","mDsqrt","mRT","mDRF","transformAngle","phi","_Vector3$applyMatrix","cosR","sinR","aClockwise","transfEllipseNoSkew","isLineCurve","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","transformPath","userData","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","shapePath","BIGNUMBER","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","classifyPoint","toPrecision","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","getScanlineIntersections","scanline","boundingBox","center","getCenter","allIntersections","forEach","containsPoint","path1","path2","intersectionsRaw","intersections","path1EdgeStart","path1EdgeEnd","_loop","path2EdgeStart","index2","path2EdgeEnd","intersection","find","getIntersections","points","identifier","isCW","sort","i1","i2","scanlineMinX","scanlineMaxX","simplePaths","getPoints","maxY","minY","maxX","minX","ShapeUtils","isClockWise","Box2","sp","isAHole","simplePath","allPaths","_fillRule","centerBoundingBox","scanlineIntersections","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","isHoleTo","fillRule","shapesToReturn","shape","Shape","hole","holes","width","lineJoin","lineCap","miterLimit","strokeColor","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","BufferGeometry","setAttribute","Float32BufferAttribute","vertexOffset","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","u1","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl","Loader"],"sourceRoot":""}