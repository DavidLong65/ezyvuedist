{"version":3,"file":"static/js/6036.23de187f.chunk.js","mappings":"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","sources":["ezyvuecore/three/examples/jsm/loaders/STLLoader.js"],"sourcesContent":["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tFileLoader,\r\n\tFloat32BufferAttribute,\r\n\tLoader,\r\n\tVector3\r\n} from '../../../build/three';\r\n\r\n/**\r\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\r\n *\r\n * Supports both binary and ASCII encoded files, with automatic detection of type.\r\n *\r\n * The loader returns a non-indexed buffer geometry.\r\n *\r\n * Limitations:\r\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\r\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\r\n *  ASCII decoding assumes file is UTF-8.\r\n *\r\n * Usage:\r\n *  const loader = new STLLoader();\r\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\r\n *    scene.add( new THREE.Mesh( geometry ) );\r\n *  });\r\n *\r\n * For binary STLs geometry might contain colors for vertices. To use it:\r\n *  // use the same code to load STL as above\r\n *  if (geometry.hasColors) {\r\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: true });\r\n *  } else { .... }\r\n *  const mesh = new THREE.Mesh( geometry, material );\r\n *\r\n * For ASCII STLs containing multiple solids, each solid is assigned to a different group.\r\n * Groups can be used to assign a different color by defining an array of materials with the same length of\r\n * geometry.groups and passing it to the Mesh constructor:\r\n *\r\n * const mesh = new THREE.Mesh( geometry, material );\r\n *\r\n * For example:\r\n *\r\n *  const materials = [];\r\n *  const nGeometryGroups = geometry.groups.length;\r\n *\r\n *  const colorMap = ...; // Some logic to index colors.\r\n *\r\n *  for (let i = 0; i < nGeometryGroups; i++) {\r\n *\r\n *\t\tconst material = new THREE.MeshPhongMaterial({\r\n *\t\t\tcolor: colorMap[i],\r\n *\t\t\twireframe: false\r\n *\t\t});\r\n *\r\n *  }\r\n *\r\n *  materials.push(material);\r\n *  const mesh = new THREE.Mesh(geometry, materials);\r\n */\r\n\r\n\r\nclass STLLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tonLoad( scope.parse( text ) );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tif ( onError ) {\r\n\r\n\t\t\t\t\tonError( e );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( data ) {\r\n\r\n\t\tfunction isBinary( data ) {\r\n\r\n\t\t\tconst reader = new DataView( data );\r\n\t\t\tconst face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );\r\n\t\t\tconst n_faces = reader.getUint32( 80, true );\r\n\t\t\tconst expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );\r\n\r\n\t\t\tif ( expect === reader.byteLength ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\r\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\r\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\r\n\r\n\t\t\t// Several encodings, such as UTF-8, precede the text with up to 5 bytes:\r\n\t\t\t// https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\r\n\t\t\t// Search for \"solid\" to start anywhere after those prefixes.\r\n\r\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\r\n\r\n\t\t\tconst solid = [ 115, 111, 108, 105, 100 ];\r\n\r\n\t\t\tfor ( let off = 0; off < 5; off ++ ) {\r\n\r\n\t\t\t\t// If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\r\n\r\n\t\t\t\tif ( matchDataViewAt( solid, reader, off ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Couldn't find \"solid\" text at the beginning; it is binary STL.\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction matchDataViewAt( query, reader, offset ) {\r\n\r\n\t\t\t// Check if each byte in query matches the corresponding byte from the current offset\r\n\r\n\t\t\tfor ( let i = 0, il = query.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( query[ i ] !== reader.getUint8( offset + i ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseBinary( data ) {\r\n\r\n\t\t\tconst reader = new DataView( data );\r\n\t\t\tconst faces = reader.getUint32( 80, true );\r\n\r\n\t\t\tlet r, g, b, hasColors = false, colors;\r\n\t\t\tlet defaultR, defaultG, defaultB, alpha;\r\n\r\n\t\t\t// process STL header\r\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\r\n\r\n\t\t\tfor ( let index = 0; index < 80 - 10; index ++ ) {\r\n\r\n\t\t\t\tif ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&\r\n\t\t\t\t\t( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {\r\n\r\n\t\t\t\t\thasColors = true;\r\n\t\t\t\t\tcolors = new Float32Array( faces * 3 * 3 );\r\n\r\n\t\t\t\t\tdefaultR = reader.getUint8( index + 6 ) / 255;\r\n\t\t\t\t\tdefaultG = reader.getUint8( index + 7 ) / 255;\r\n\t\t\t\t\tdefaultB = reader.getUint8( index + 8 ) / 255;\r\n\t\t\t\t\talpha = reader.getUint8( index + 9 ) / 255;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst dataOffset = 84;\r\n\t\t\tconst faceLength = 12 * 4 + 2;\r\n\r\n\t\t\tconst geometry = new BufferGeometry();\r\n\r\n\t\t\tconst vertices = new Float32Array( faces * 3 * 3 );\r\n\t\t\tconst normals = new Float32Array( faces * 3 * 3 );\r\n\r\n\t\t\tfor ( let face = 0; face < faces; face ++ ) {\r\n\r\n\t\t\t\tconst start = dataOffset + face * faceLength;\r\n\t\t\t\tconst normalX = reader.getFloat32( start, true );\r\n\t\t\t\tconst normalY = reader.getFloat32( start + 4, true );\r\n\t\t\t\tconst normalZ = reader.getFloat32( start + 8, true );\r\n\r\n\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\tconst packedColor = reader.getUint16( start + 48, true );\r\n\r\n\t\t\t\t\tif ( ( packedColor & 0x8000 ) === 0 ) {\r\n\r\n\t\t\t\t\t\t// facet has its own unique color\r\n\r\n\t\t\t\t\t\tr = ( packedColor & 0x1F ) / 31;\r\n\t\t\t\t\t\tg = ( ( packedColor >> 5 ) & 0x1F ) / 31;\r\n\t\t\t\t\t\tb = ( ( packedColor >> 10 ) & 0x1F ) / 31;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tr = defaultR;\r\n\t\t\t\t\t\tg = defaultG;\r\n\t\t\t\t\t\tb = defaultB;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 1; i <= 3; i ++ ) {\r\n\r\n\t\t\t\t\tconst vertexstart = start + i * 12;\r\n\t\t\t\t\tconst componentIdx = ( face * 3 * 3 ) + ( ( i - 1 ) * 3 );\r\n\r\n\t\t\t\t\tvertices[ componentIdx ] = reader.getFloat32( vertexstart, true );\r\n\t\t\t\t\tvertices[ componentIdx + 1 ] = reader.getFloat32( vertexstart + 4, true );\r\n\t\t\t\t\tvertices[ componentIdx + 2 ] = reader.getFloat32( vertexstart + 8, true );\r\n\r\n\t\t\t\t\tnormals[ componentIdx ] = normalX;\r\n\t\t\t\t\tnormals[ componentIdx + 1 ] = normalY;\r\n\t\t\t\t\tnormals[ componentIdx + 2 ] = normalZ;\r\n\r\n\t\t\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\t\t\tcolors[ componentIdx ] = r;\r\n\t\t\t\t\t\tcolors[ componentIdx + 1 ] = g;\r\n\t\t\t\t\t\tcolors[ componentIdx + 2 ] = b;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );\r\n\t\t\tgeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\tif ( hasColors ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );\r\n\t\t\t\tgeometry.hasColors = true;\r\n\t\t\t\tgeometry.alpha = alpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseASCII( data ) {\r\n\r\n\t\t\tconst geometry = new BufferGeometry();\r\n\t\t\tconst patternSolid = /solid([\\s\\S]*?)endsolid/g;\r\n\t\t\tconst patternFace = /facet([\\s\\S]*?)endfacet/g;\r\n\t\t\tlet faceCounter = 0;\r\n\r\n\t\t\tconst patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\r\n\t\t\tconst patternVertex = new RegExp( 'vertex' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\t\t\tconst patternNormal = new RegExp( 'normal' + patternFloat + patternFloat + patternFloat, 'g' );\r\n\r\n\t\t\tconst vertices = [];\r\n\t\t\tconst normals = [];\r\n\r\n\t\t\tconst normal = new Vector3();\r\n\r\n\t\t\tlet result;\r\n\r\n\t\t\tlet groupCount = 0;\r\n\t\t\tlet startVertex = 0;\r\n\t\t\tlet endVertex = 0;\r\n\r\n\t\t\twhile ( ( result = patternSolid.exec( data ) ) !== null ) {\r\n\r\n\t\t\t\tstartVertex = endVertex;\r\n\r\n\t\t\t\tconst solid = result[ 0 ];\r\n\r\n\t\t\t\twhile ( ( result = patternFace.exec( solid ) ) !== null ) {\r\n\r\n\t\t\t\t\tlet vertexCountPerFace = 0;\r\n\t\t\t\t\tlet normalCountPerFace = 0;\r\n\r\n\t\t\t\t\tconst text = result[ 0 ];\r\n\r\n\t\t\t\t\twhile ( ( result = patternNormal.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tnormal.x = parseFloat( result[ 1 ] );\r\n\t\t\t\t\t\tnormal.y = parseFloat( result[ 2 ] );\r\n\t\t\t\t\t\tnormal.z = parseFloat( result[ 3 ] );\r\n\t\t\t\t\t\tnormalCountPerFace ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\twhile ( ( result = patternVertex.exec( text ) ) !== null ) {\r\n\r\n\t\t\t\t\t\tvertices.push( parseFloat( result[ 1 ] ), parseFloat( result[ 2 ] ), parseFloat( result[ 3 ] ) );\r\n\t\t\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\t\t\t\t\tvertexCountPerFace ++;\r\n\t\t\t\t\t\tendVertex ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// every face have to own ONE valid normal\r\n\r\n\t\t\t\t\tif ( normalCountPerFace !== 1 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// each face have to own THREE valid vertices\r\n\r\n\t\t\t\t\tif ( vertexCountPerFace !== 3 ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfaceCounter ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst start = startVertex;\r\n\t\t\t\tconst count = endVertex - startVertex;\r\n\r\n\t\t\t\tgeometry.addGroup( start, count, groupCount );\r\n\t\t\t\tgroupCount ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\r\n\t\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\r\n\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureString( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer !== 'string' ) {\r\n\r\n\t\t\t\treturn new TextDecoder().decode( buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t}\r\n\r\n\t\tfunction ensureBinary( buffer ) {\r\n\r\n\t\t\tif ( typeof buffer === 'string' ) {\r\n\r\n\t\t\t\tconst array_buffer = new Uint8Array( buffer.length );\r\n\t\t\t\tfor ( let i = 0; i < buffer.length; i ++ ) {\r\n\r\n\t\t\t\t\tarray_buffer[ i ] = buffer.charCodeAt( i ) & 0xff; // implicitly assumes little-endian\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn array_buffer.buffer || array_buffer;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn buffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// start\r\n\r\n\t\tconst binData = ensureBinary( data );\r\n\r\n\t\treturn isBinary( binData ) ? parseBinary( binData ) : parseASCII( ensureString( data ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { STLLoader };\r\n"],"names":["STLLoader","_Loader","_inherits","_super","_createSuper","manager","_classCallCheck","call","_createClass","key","value","url","onLoad","onProgress","onError","scope","this","loader","FileLoader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","data","matchDataViewAt","query","reader","offset","i","il","length","getUint8","buffer","binData","array_buffer","Uint8Array","charCodeAt","ensureBinary","DataView","getUint32","byteLength","solid","off","isBinary","r","g","b","colors","defaultR","defaultG","defaultB","alpha","faces","hasColors","index","Float32Array","geometry","BufferGeometry","vertices","normals","face","start","normalX","getFloat32","normalY","normalZ","packedColor","getUint16","vertexstart","componentIdx","setAttribute","BufferAttribute","parseBinary","result","patternSolid","patternFace","faceCounter","patternFloat","source","patternVertex","RegExp","patternNormal","normal","Vector3","groupCount","startVertex","endVertex","exec","vertexCountPerFace","normalCountPerFace","x","parseFloat","y","z","push","count","addGroup","Float32BufferAttribute","parseASCII","TextDecoder","decode","Loader"],"sourceRoot":""}