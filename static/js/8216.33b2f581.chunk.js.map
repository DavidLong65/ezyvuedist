{"version":3,"file":"static/js/8216.33b2f581.chunk.js","mappings":"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","sources":["ezyvuecore/three/examples/jsm/loaders/LDrawLoader.js"],"sourcesContent":["import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tColor,\r\n\tFileLoader,\r\n\tGroup,\r\n\tLineBasicMaterial,\r\n\tLineSegments,\r\n\tLoader,\r\n\tMatrix4,\r\n\tMesh,\r\n\tMeshStandardMaterial,\r\n\tShaderMaterial,\r\n\tUniformsLib,\r\n\tUniformsUtils,\r\n\tVector3,\r\n\tRay\r\n} from '../../../build/three';\r\n\r\n// Special surface finish tag types.\r\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\r\nconst FINISH_TYPE_DEFAULT = 0;\r\nconst FINISH_TYPE_CHROME = 1;\r\nconst FINISH_TYPE_PEARLESCENT = 2;\r\nconst FINISH_TYPE_RUBBER = 3;\r\nconst FINISH_TYPE_MATTE_METALLIC = 4;\r\nconst FINISH_TYPE_METAL = 5;\r\n\r\n// State machine to search a subobject path.\r\n// The LDraw standard establishes these various possible subfolders.\r\nconst FILE_LOCATION_TRY_PARTS = 0;\r\nconst FILE_LOCATION_TRY_P = 1;\r\nconst FILE_LOCATION_TRY_MODELS = 2;\r\nconst FILE_LOCATION_AS_IS = 3;\r\nconst FILE_LOCATION_TRY_RELATIVE = 4;\r\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\r\nconst FILE_LOCATION_NOT_FOUND = 6;\r\n\r\nconst MAIN_COLOUR_CODE = '16';\r\nconst MAIN_EDGE_COLOUR_CODE = '24';\r\n\r\nconst _tempVec0 = new Vector3();\r\nconst _tempVec1 = new Vector3();\r\n\r\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\t\tUniformsLib.fog,\r\n\t\t\t\t{\r\n\t\t\t\t\tdiffuse: {\r\n\t\t\t\t\t\tvalue: new Color()\r\n\t\t\t\t\t},\r\n\t\t\t\t\topacity: {\r\n\t\t\t\t\t\tvalue: 1.0\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t] ),\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tattribute vec3 control0;\r\n\t\t\t\tattribute vec3 control1;\r\n\t\t\t\tattribute vec3 direction;\r\n\t\t\t\tvarying float discardFlag;\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <color_pars_vertex>\r\n\t\t\t\t#include <fog_pars_vertex>\r\n\t\t\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t\t\t#include <clipping_planes_pars_vertex>\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\t#include <color_vertex>\r\n\r\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\r\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\r\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\r\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\r\n\r\n\t\t\t\t\tc0.xy /= c0.w;\r\n\t\t\t\t\tc1.xy /= c1.w;\r\n\t\t\t\t\tp0.xy /= p0.w;\r\n\t\t\t\t\tp1.xy /= p1.w;\r\n\r\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\r\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\r\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\r\n\r\n\t\t\t\t\t// Get control point directions from the line\r\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\r\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\r\n\r\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\r\n\t\t\t\t\t// from the line segment then the line should not be drawn.\r\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\r\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\r\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\r\n\r\n\t\t\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t\t\t#include <fog_vertex>\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\tuniform vec3 diffuse;\r\n\t\t\tuniform float opacity;\r\n\t\t\tvarying float discardFlag;\r\n\r\n\t\t\t#include <common>\r\n\t\t\t#include <color_pars_fragment>\r\n\t\t\t#include <fog_pars_fragment>\r\n\t\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t\t#include <clipping_planes_pars_fragment>\r\n\t\t\tvoid main() {\r\n\r\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\r\n\r\n\t\t\t\t#include <clipping_planes_fragment>\r\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\r\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\t\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t\t#include <color_fragment>\r\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\t\t\t\t#include <tonemapping_fragment>\r\n\t\t\t\t#include <encodings_fragment>\r\n\t\t\t\t#include <fog_fragment>\r\n\t\t\t\t#include <premultiplied_alpha_fragment>\r\n\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\topacity: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn this.uniforms.opacity.value;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tset: function ( value ) {\r\n\r\n\t\t\t\t\tthis.uniforms.opacity.value = value;\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tcolor: {\r\n\t\t\t\tget: function () {\r\n\r\n\t\t\t\t\treturn this.uniforms.diffuse.value;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\t\tthis.isLDrawConditionalLineMaterial = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass ConditionalLineSegments extends LineSegments {\r\n\r\n\tconstructor( geometry, material ) {\r\n\r\n\t\tsuper( geometry, material );\r\n\t\tthis.isConditionalLine = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction generateFaceNormals( faces ) {\r\n\r\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tconst face = faces[ i ];\r\n\t\tconst vertices = face.vertices;\r\n\t\tconst v0 = vertices[ 0 ];\r\n\t\tconst v1 = vertices[ 1 ];\r\n\t\tconst v2 = vertices[ 2 ];\r\n\r\n\t\t_tempVec0.subVectors( v1, v0 );\r\n\t\t_tempVec1.subVectors( v2, v1 );\r\n\t\tface.faceNormal = new Vector3()\r\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\r\n\t\t\t.normalize();\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _ray = new Ray();\r\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\r\n\r\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\r\n\t// it allows edges to be smoothed as expected (see minifig arms).\r\n\t// --\r\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\r\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\r\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\r\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\r\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\r\n\r\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\r\n\tfunction hashVertex( v ) {\r\n\r\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\r\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\r\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\r\n\r\n\t\treturn `${ x },${ y },${ z }`;\r\n\r\n\t}\r\n\r\n\tfunction hashEdge( v0, v1 ) {\r\n\r\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\r\n\r\n\t}\r\n\r\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\r\n\t// onto the original line.\r\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\r\n\r\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\r\n\r\n\t\tconst scalar = v0.dot( targetRay.direction );\r\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\r\n\r\n\t\treturn targetRay;\r\n\r\n\t}\r\n\r\n\tfunction hashRay( ray ) {\r\n\r\n\t\treturn hashEdge( ray.origin, ray.direction );\r\n\r\n\t}\r\n\r\n\tconst hardEdges = new Set();\r\n\tconst hardEdgeRays = new Map();\r\n\tconst halfEdgeList = {};\r\n\tconst normals = [];\r\n\r\n\t// Save the list of hard edges by hash\r\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\r\n\r\n\t\tconst ls = lineSegments[ i ];\r\n\t\tconst vertices = ls.vertices;\r\n\t\tconst v0 = vertices[ 0 ];\r\n\t\tconst v1 = vertices[ 1 ];\r\n\t\thardEdges.add( hashEdge( v0, v1 ) );\r\n\t\thardEdges.add( hashEdge( v1, v0 ) );\r\n\r\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\r\n\t\t// and requires more memory.\r\n\t\tif ( checkSubSegments ) {\r\n\r\n\t\t\t// add both ray directions to the map\r\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\r\n\t\t\tconst rh1 = hashRay( ray );\r\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\r\n\r\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\r\n\t\t\t\tconst rh2 = hashRay( ray );\r\n\r\n\t\t\t\tconst info = {\r\n\t\t\t\t\tray,\r\n\t\t\t\t\tdistances: [],\r\n\t\t\t\t};\r\n\r\n\t\t\t\thardEdgeRays.set( rh1, info );\r\n\t\t\t\thardEdgeRays.set( rh2, info );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\r\n\t\t\t// subsegment later.\r\n\t\t\tconst info = hardEdgeRays.get( rh1 );\r\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\r\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\r\n\t\t\tif ( d0 > d1 ) {\r\n\r\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinfo.distances.push( d0, d1 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// track the half edges associated with each triangle\r\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tconst tri = faces[ i ];\r\n\t\tconst vertices = tri.vertices;\r\n\t\tconst vertCount = vertices.length;\r\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\r\n\r\n\t\t\tconst index = i2;\r\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\r\n\t\t\tconst v0 = vertices[ index ];\r\n\t\t\tconst v1 = vertices[ next ];\r\n\t\t\tconst hash = hashEdge( v0, v1 );\r\n\r\n\t\t\t// don't add the triangle if the edge is supposed to be hard\r\n\t\t\tif ( hardEdges.has( hash ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\r\n\t\t\tif ( checkSubSegments ) {\r\n\r\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\r\n\r\n\t\t\t\tconst rayHash = hashRay( _ray );\r\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\r\n\r\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\r\n\t\t\t\t\tconst { ray, distances } = info;\r\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\r\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\r\n\r\n\t\t\t\t\tif ( d0 > d1 ) {\r\n\r\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\r\n\t\t\t\t\tlet found = false;\r\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\r\n\r\n\t\t\t\t\t\t\tfound = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( found ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst info = {\r\n\t\t\t\tindex: index,\r\n\t\t\t\ttri: tri\r\n\t\t\t};\r\n\t\t\thalfEdgeList[ hash ] = info;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Iterate until we've tried to connect all faces to share normals\r\n\twhile ( true ) {\r\n\r\n\t\t// Stop if there are no more faces left\r\n\t\tlet halfEdge = null;\r\n\t\tfor ( const key in halfEdgeList ) {\r\n\r\n\t\t\thalfEdge = halfEdgeList[ key ];\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( halfEdge === null ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t// Exhaustively find all connected faces\r\n\t\tconst queue = [ halfEdge ];\r\n\t\twhile ( queue.length > 0 ) {\r\n\r\n\t\t\t// initialize all vertex normals in this triangle\r\n\t\t\tconst tri = queue.pop().tri;\r\n\t\t\tconst vertices = tri.vertices;\r\n\t\t\tconst vertNormals = tri.normals;\r\n\t\t\tconst faceNormal = tri.faceNormal;\r\n\r\n\t\t\t// Check if any edge is connected to another triangle edge\r\n\t\t\tconst vertCount = vertices.length;\r\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\r\n\r\n\t\t\t\tconst index = i2;\r\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\r\n\t\t\t\tconst v0 = vertices[ index ];\r\n\t\t\t\tconst v1 = vertices[ next ];\r\n\r\n\t\t\t\t// delete this triangle from the list so it won't be found again\r\n\t\t\t\tconst hash = hashEdge( v0, v1 );\r\n\t\t\t\tdelete halfEdgeList[ hash ];\r\n\r\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\r\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\r\n\t\t\t\tif ( otherInfo ) {\r\n\r\n\t\t\t\t\tconst otherTri = otherInfo.tri;\r\n\t\t\t\t\tconst otherIndex = otherInfo.index;\r\n\t\t\t\t\tconst otherNormals = otherTri.normals;\r\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\r\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\r\n\r\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\r\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\r\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\r\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\r\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\r\n\t\t\t\t\t// it so it won't be found again.\r\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\r\n\r\n\t\t\t\t\t\tqueue.push( otherInfo );\r\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// share the first normal\r\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\r\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\r\n\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\r\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\r\n\t\t\t\t\tif ( sharedNormal1 === null ) {\r\n\r\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\r\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\r\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\r\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\r\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\r\n\r\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\r\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\r\n\r\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\r\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// share the second normal\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\r\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\r\n\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\r\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\r\n\t\t\t\t\tif ( sharedNormal2 === null ) {\r\n\r\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\r\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\r\n\r\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\r\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\r\n\r\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\r\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\r\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\r\n\r\n\t\tnormals[ i ].normalize();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction isPartType( type ) {\r\n\r\n\treturn type === 'Part' || type === 'Unofficial_Part';\r\n\r\n}\r\n\r\nfunction isPrimitiveType( type ) {\r\n\r\n\treturn /primitive/i.test( type ) || type === 'Subpart';\r\n\r\n}\r\n\r\nclass LineParser {\r\n\r\n\tconstructor( line, lineNumber ) {\r\n\r\n\t\tthis.line = line;\r\n\t\tthis.lineLength = line.length;\r\n\t\tthis.currentCharIndex = 0;\r\n\t\tthis.currentChar = ' ';\r\n\t\tthis.lineNumber = lineNumber;\r\n\r\n\t}\r\n\r\n\tseekNonSpace() {\r\n\r\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\r\n\r\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\r\n\r\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.currentCharIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetToken() {\r\n\r\n\t\tconst pos0 = this.currentCharIndex ++;\r\n\r\n\t\t// Seek space\r\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\r\n\r\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\r\n\r\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.currentCharIndex ++;\r\n\r\n\t\t}\r\n\r\n\t\tconst pos1 = this.currentCharIndex;\r\n\r\n\t\tthis.seekNonSpace();\r\n\r\n\t\treturn this.line.substring( pos0, pos1 );\r\n\r\n\t}\r\n\r\n\tgetVector() {\r\n\r\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\r\n\r\n\t}\r\n\r\n\tgetRemainingString() {\r\n\r\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\r\n\r\n\t}\r\n\r\n\tisAtTheEnd() {\r\n\r\n\t\treturn this.currentCharIndex >= this.lineLength;\r\n\r\n\t}\r\n\r\n\tsetToEnd() {\r\n\r\n\t\tthis.currentCharIndex = this.lineLength;\r\n\r\n\t}\r\n\r\n\tgetLineNumberString() {\r\n\r\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Fetches and parses an intermediate representation of LDraw parts files.\r\nclass LDrawParsedCache {\r\n\r\n\tconstructor( loader ) {\r\n\r\n\t\tthis.loader = loader;\r\n\t\tthis._cache = {};\r\n\r\n\t}\r\n\r\n\tcloneResult( original ) {\r\n\r\n\t\tconst result = {};\r\n\r\n\t\t// vertices are transformed and normals computed before being converted to geometry\r\n\t\t// so these pieces must be cloned.\r\n\t\tresult.faces = original.faces.map( face => {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcolorCode: face.colorCode,\r\n\t\t\t\tmaterial: face.material,\r\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\r\n\t\t\t\tnormals: face.normals.map( () => null ),\r\n\t\t\t\tfaceNormal: null\r\n\t\t\t};\r\n\r\n\t\t} );\r\n\r\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcolorCode: face.colorCode,\r\n\t\t\t\tmaterial: face.material,\r\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\r\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\r\n\t\t\t};\r\n\r\n\t\t} );\r\n\r\n\t\tresult.lineSegments = original.lineSegments.map( face => {\r\n\r\n\t\t\treturn {\r\n\t\t\t\tcolorCode: face.colorCode,\r\n\t\t\t\tmaterial: face.material,\r\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\r\n\t\t\t};\r\n\r\n\t\t} );\r\n\r\n\t\t// none if this is subsequently modified\r\n\t\tresult.type = original.type;\r\n\t\tresult.category = original.category;\r\n\t\tresult.keywords = original.keywords;\r\n\t\tresult.author = original.author;\r\n\t\tresult.subobjects = original.subobjects;\r\n\t\tresult.fileName = original.fileName;\r\n\t\tresult.totalFaces = original.totalFaces;\r\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\r\n\t\tresult.materials = original.materials;\r\n\t\tresult.group = null;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tasync fetchData( fileName ) {\r\n\r\n\t\tlet triedLowerCase = false;\r\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\r\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\r\n\r\n\t\t\tlet subobjectURL = fileName;\r\n\t\t\tswitch ( locationState ) {\r\n\r\n\t\t\t\tcase FILE_LOCATION_AS_IS:\r\n\t\t\t\t\tlocationState = locationState + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\r\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\r\n\t\t\t\t\tlocationState = locationState + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase FILE_LOCATION_TRY_P:\r\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\r\n\t\t\t\t\tlocationState = locationState + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\r\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\r\n\t\t\t\t\tlocationState = locationState + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\r\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\r\n\t\t\t\t\tlocationState = locationState + 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\r\n\r\n\t\t\t\t\tif ( triedLowerCase ) {\r\n\r\n\t\t\t\t\t\t// Try absolute path\r\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Next attempt is lower case\r\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\r\n\t\t\t\t\t\tsubobjectURL = fileName;\r\n\t\t\t\t\t\ttriedLowerCase = true;\r\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst loader = this.loader;\r\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\r\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\r\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\r\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\r\n\t\t\t\treturn text;\r\n\r\n\t\t\t} catch {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\r\n\r\n\t}\r\n\r\n\tparse( text, fileName = null ) {\r\n\r\n\t\tconst loader = this.loader;\r\n\r\n\t\t// final results\r\n\t\tconst faces = [];\r\n\t\tconst lineSegments = [];\r\n\t\tconst conditionalSegments = [];\r\n\t\tconst subobjects = [];\r\n\t\tconst materials = {};\r\n\r\n\t\tconst getLocalMaterial = colorCode => {\r\n\r\n\t\t\treturn materials[ colorCode ] || null;\r\n\r\n\t\t};\r\n\r\n\t\tlet type = 'Model';\r\n\t\tlet category = null;\r\n\t\tlet keywords = null;\r\n\t\tlet author = null;\r\n\t\tlet totalFaces = 0;\r\n\r\n\t\t// split into lines\r\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\r\n\r\n\t\t\t// This is faster than String.split with regex that splits on both\r\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tconst lines = text.split( '\\n' );\r\n\t\tconst numLines = lines.length;\r\n\r\n\t\tlet parsingEmbeddedFiles = false;\r\n\t\tlet currentEmbeddedFileName = null;\r\n\t\tlet currentEmbeddedText = null;\r\n\r\n\t\tlet bfcCertified = false;\r\n\t\tlet bfcCCW = true;\r\n\t\tlet bfcInverted = false;\r\n\t\tlet bfcCull = true;\r\n\r\n\t\tlet startingBuildingStep = false;\r\n\r\n\t\t// Parse all line commands\r\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\r\n\r\n\t\t\tconst line = lines[ lineIndex ];\r\n\r\n\t\t\tif ( line.length === 0 ) continue;\r\n\r\n\t\t\tif ( parsingEmbeddedFiles ) {\r\n\r\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\r\n\r\n\t\t\t\t\t// Save previous embedded file in the cache\r\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\r\n\r\n\t\t\t\t\t// New embedded text file\r\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\r\n\t\t\t\t\tcurrentEmbeddedText = '';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\r\n\t\t\tlp.seekNonSpace();\r\n\r\n\t\t\tif ( lp.isAtTheEnd() ) {\r\n\r\n\t\t\t\t// Empty line\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Parse the line type\r\n\t\t\tconst lineType = lp.getToken();\r\n\r\n\t\t\tlet material;\r\n\t\t\tlet colorCode;\r\n\t\t\tlet segment;\r\n\t\t\tlet ccw;\r\n\t\t\tlet doubleSided;\r\n\t\t\tlet v0, v1, v2, v3, c0, c1;\r\n\r\n\t\t\tswitch ( lineType ) {\r\n\r\n\t\t\t\t// Line type 0: Comment or META\r\n\t\t\t\tcase '0':\r\n\r\n\t\t\t\t\t// Parse meta directive\r\n\t\t\t\t\tconst meta = lp.getToken();\r\n\r\n\t\t\t\t\tif ( meta ) {\r\n\r\n\t\t\t\t\t\tswitch ( meta ) {\r\n\r\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\r\n\r\n\t\t\t\t\t\t\t\ttype = lp.getToken();\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase '!COLOUR':\r\n\r\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\r\n\t\t\t\t\t\t\t\tif ( material ) {\r\n\r\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\r\n\r\n\t\t\t\t\t\t\t\t}\telse {\r\n\r\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase '!CATEGORY':\r\n\r\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase '!KEYWORDS':\r\n\r\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\r\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\r\n\r\n\t\t\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'FILE':\r\n\r\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\r\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\r\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\r\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\r\n\r\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\r\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'BFC':\r\n\r\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\r\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\r\n\r\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\r\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\r\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\r\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\r\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'STEP':\r\n\r\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 'Author:':\r\n\r\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\r\n\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// Line type 1: Sub-object file\r\n\t\t\t\tcase '1':\r\n\r\n\t\t\t\t\tcolorCode = lp.getToken();\r\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\r\n\r\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\r\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\r\n\r\n\t\t\t\t\tconst matrix = new Matrix4().set(\r\n\t\t\t\t\t\tm0, m1, m2, posX,\r\n\t\t\t\t\t\tm3, m4, m5, posY,\r\n\t\t\t\t\t\tm6, m7, m8, posZ,\r\n\t\t\t\t\t\t0, 0, 0, 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\r\n\r\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\r\n\r\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\r\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// Standardized subfolders\r\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\r\n\r\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\r\n\r\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\r\n\r\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsubobjects.push( {\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\tmatrix: matrix,\r\n\t\t\t\t\t\tfileName: fileName,\r\n\t\t\t\t\t\tinverted: bfcInverted,\r\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tstartingBuildingStep = false;\r\n\t\t\t\t\tbfcInverted = false;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// Line type 2: Line segment\r\n\t\t\t\tcase '2':\r\n\r\n\t\t\t\t\tcolorCode = lp.getToken();\r\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\r\n\t\t\t\t\tv0 = lp.getVector();\r\n\t\t\t\t\tv1 = lp.getVector();\r\n\r\n\t\t\t\t\tsegment = {\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\tvertices: [ v0, v1 ],\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tlineSegments.push( segment );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// Line type 5: Conditional Line segment\r\n\t\t\t\tcase '5':\r\n\r\n\t\t\t\t\tcolorCode = lp.getToken();\r\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\r\n\t\t\t\t\tv0 = lp.getVector();\r\n\t\t\t\t\tv1 = lp.getVector();\r\n\t\t\t\t\tc0 = lp.getVector();\r\n\t\t\t\t\tc1 = lp.getVector();\r\n\r\n\t\t\t\t\tsegment = {\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\tvertices: [ v0, v1 ],\r\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\tconditionalSegments.push( segment );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// Line type 3: Triangle\r\n\t\t\t\tcase '3':\r\n\r\n\t\t\t\t\tcolorCode = lp.getToken();\r\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\r\n\t\t\t\t\tccw = bfcCCW;\r\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\r\n\r\n\t\t\t\t\tif ( ccw === true ) {\r\n\r\n\t\t\t\t\t\tv0 = lp.getVector();\r\n\t\t\t\t\t\tv1 = lp.getVector();\r\n\t\t\t\t\t\tv2 = lp.getVector();\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv2 = lp.getVector();\r\n\t\t\t\t\t\tv1 = lp.getVector();\r\n\t\t\t\t\t\tv0 = lp.getVector();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfaces.push( {\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\tfaceNormal: null,\r\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\r\n\t\t\t\t\t\tnormals: [ null, null, null ],\r\n\t\t\t\t\t} );\r\n\t\t\t\t\ttotalFaces ++;\r\n\r\n\t\t\t\t\tif ( doubleSided === true ) {\r\n\r\n\t\t\t\t\t\tfaces.push( {\r\n\t\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\t\tfaceNormal: null,\r\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\r\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\ttotalFaces ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t// Line type 4: Quadrilateral\r\n\t\t\t\tcase '4':\r\n\r\n\t\t\t\t\tcolorCode = lp.getToken();\r\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\r\n\t\t\t\t\tccw = bfcCCW;\r\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\r\n\r\n\t\t\t\t\tif ( ccw === true ) {\r\n\r\n\t\t\t\t\t\tv0 = lp.getVector();\r\n\t\t\t\t\t\tv1 = lp.getVector();\r\n\t\t\t\t\t\tv2 = lp.getVector();\r\n\t\t\t\t\t\tv3 = lp.getVector();\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tv3 = lp.getVector();\r\n\t\t\t\t\t\tv2 = lp.getVector();\r\n\t\t\t\t\t\tv1 = lp.getVector();\r\n\t\t\t\t\t\tv0 = lp.getVector();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\r\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\r\n\t\t\t\t\tfaces.push( {\r\n\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\tfaceNormal: null,\r\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\r\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\r\n\t\t\t\t\t} );\r\n\t\t\t\t\ttotalFaces += 2;\r\n\r\n\t\t\t\t\tif ( doubleSided === true ) {\r\n\r\n\t\t\t\t\t\tfaces.push( {\r\n\t\t\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\t\t\tcolorCode: colorCode,\r\n\t\t\t\t\t\t\tfaceNormal: null,\r\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\r\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\t\ttotalFaces += 2;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( parsingEmbeddedFiles ) {\r\n\r\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tfaces,\r\n\t\t\tconditionalSegments,\r\n\t\t\tlineSegments,\r\n\t\t\ttype,\r\n\t\t\tcategory,\r\n\t\t\tkeywords,\r\n\t\t\tauthor,\r\n\t\t\tsubobjects,\r\n\t\t\ttotalFaces,\r\n\t\t\tstartingBuildingStep,\r\n\t\t\tmaterials,\r\n\t\t\tfileName,\r\n\t\t\tgroup: null\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t// returns an (optionally cloned) instance of the data\r\n\tgetData( fileName, clone = true ) {\r\n\r\n\t\tconst key = fileName.toLowerCase();\r\n\t\tconst result = this._cache[ key ];\r\n\t\tif ( result === null || result instanceof Promise ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( clone ) {\r\n\r\n\t\t\treturn this.cloneResult( result );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\r\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\r\n\tasync ensureDataLoaded( fileName ) {\r\n\r\n\t\tconst key = fileName.toLowerCase();\r\n\t\tif ( ! ( key in this._cache ) ) {\r\n\r\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\r\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\r\n\r\n\t\t\t\tconst info = this.parse( text, fileName );\r\n\t\t\t\tthis._cache[ key ] = info;\r\n\t\t\t\treturn info;\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tawait this._cache[ key ];\r\n\r\n\t}\r\n\r\n\t// sets the data in the cache from parsed data\r\n\tsetData( fileName, text ) {\r\n\r\n\t\tconst key = fileName.toLowerCase();\r\n\t\tthis._cache[ key ] = this.parse( text, fileName );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\r\n// an edge then the passthroughColorCode is used.\r\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\r\n\r\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\r\n\tif ( isPassthrough ) {\r\n\r\n\t\tcolorCode = parentColorCode;\r\n\r\n\t}\r\n\r\n\treturn materialHierarchy[ colorCode ] || null;\r\n\r\n}\r\n\r\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\r\nclass LDrawPartsGeometryCache {\r\n\r\n\tconstructor( loader ) {\r\n\r\n\t\tthis.loader = loader;\r\n\t\tthis.parseCache = new LDrawParsedCache( loader );\r\n\t\tthis._cache = {};\r\n\r\n\t}\r\n\r\n\t// Convert the given file information into a mesh by processing subobjects.\r\n\tasync processIntoMesh( info ) {\r\n\r\n\t\tconst loader = this.loader;\r\n\t\tconst parseCache = this.parseCache;\r\n\t\tconst faceMaterials = new Set();\r\n\r\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\r\n\t\t// piece object.\r\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\r\n\r\n\t\t\tconst subobjects = info.subobjects;\r\n\t\t\tconst promises = [];\r\n\r\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\r\n\t\t\t// group which lets instruction steps apply correctly.\r\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst subobject = subobjects[ i ];\r\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\r\n\r\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\r\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\r\n\r\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( error );\r\n\t\t\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tpromises.push( promise );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst group = new Group();\r\n\t\t\tgroup.userData.category = info.category;\r\n\t\t\tgroup.userData.keywords = info.keywords;\r\n\t\t\tgroup.userData.author = info.author;\r\n\t\t\tgroup.userData.type = info.type;\r\n\t\t\tgroup.userData.fileName = info.fileName;\r\n\t\t\tinfo.group = group;\r\n\r\n\t\t\tconst subobjectInfos = await Promise.all( promises );\r\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst subobject = info.subobjects[ i ];\r\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\r\n\r\n\t\t\t\tif ( subobjectInfo === null ) {\r\n\r\n\t\t\t\t\t// the subobject failed to load\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\r\n\t\t\t\tif ( subobjectInfo.isGroup ) {\r\n\r\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\r\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\r\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\r\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\r\n\r\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\r\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\r\n\r\n\t\t\t\t\tgroup.add( subobjectGroup );\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\r\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\r\n\r\n\t\t\t\t\tgroup.add( subobjectInfo.group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\r\n\t\t\t\t// to the parent primitives list.\r\n\t\t\t\tconst parentLineSegments = info.lineSegments;\r\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\r\n\t\t\t\tconst parentFaces = info.faces;\r\n\r\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\r\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\r\n\r\n\t\t\t\tconst faces = subobjectInfo.faces;\r\n\t\t\t\tconst matrix = subobject.matrix;\r\n\t\t\t\tconst inverted = subobject.inverted;\r\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\r\n\t\t\t\tconst colorCode = subobject.colorCode;\r\n\r\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\r\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst ls = lineSegments[ i ];\r\n\t\t\t\t\tconst vertices = ls.vertices;\r\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\r\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\r\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\r\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\r\n\r\n\t\t\t\t\tparentLineSegments.push( ls );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst os = conditionalSegments[ i ];\r\n\t\t\t\t\tconst vertices = os.vertices;\r\n\t\t\t\t\tconst controlPoints = os.controlPoints;\r\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\r\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\r\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\r\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\r\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\r\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\r\n\r\n\t\t\t\t\tparentConditionalSegments.push( os );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst tri = faces[ i ];\r\n\t\t\t\t\tconst vertices = tri.vertices;\r\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\r\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\r\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\r\n\r\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\r\n\t\t\t\t\t// needs to be flipped.\r\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\r\n\r\n\t\t\t\t\t\tvertices.reverse();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tparentFaces.push( tri );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\r\n\t\t\t// to material scoping.\r\n\t\t\tif ( subobject ) {\r\n\r\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\r\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn info;\r\n\r\n\t\t};\r\n\r\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\r\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\r\n\r\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\r\n\r\n\t\t}\r\n\r\n\t\tawait processInfoSubobjects( info );\r\n\r\n\t\tif ( loader.smoothNormals ) {\r\n\r\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\r\n\t\t\tgenerateFaceNormals( info.faces );\r\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\r\n\r\n\t\t}\r\n\r\n\t\t// Add the primitive objects and metadata.\r\n\t\tconst group = info.group;\r\n\t\tif ( info.faces.length > 0 ) {\r\n\r\n\t\t\tgroup.add( createObject( info.faces, 3, false, info.totalFaces ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( info.lineSegments.length > 0 ) {\r\n\r\n\t\t\tgroup.add( createObject( info.lineSegments, 2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( info.conditionalSegments.length > 0 ) {\r\n\r\n\t\t\tgroup.add( createObject( info.conditionalSegments, 2, true ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t}\r\n\r\n\thasCachedModel( fileName ) {\r\n\r\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\r\n\r\n\t}\r\n\r\n\tasync getCachedModel( fileName ) {\r\n\r\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\r\n\r\n\t\t\tconst key = fileName.toLowerCase();\r\n\t\t\tconst group = await this._cache[ key ];\r\n\t\t\treturn group.clone();\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\r\n\tasync loadModel( fileName ) {\r\n\r\n\t\tconst parseCache = this.parseCache;\r\n\t\tconst key = fileName.toLowerCase();\r\n\t\tif ( this.hasCachedModel( fileName ) ) {\r\n\r\n\t\t\t// Return cached model if available.\r\n\t\t\treturn this.getCachedModel( fileName );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Otherwise parse a new model.\r\n\t\t\t// Ensure the file data is loaded and pre parsed.\r\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\r\n\r\n\t\t\tconst info = parseCache.getData( fileName );\r\n\t\t\tconst promise = this.processIntoMesh( info );\r\n\r\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\r\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\r\n\t\t\t// do unnecessary work.\r\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\r\n\r\n\t\t\t\treturn this.getCachedModel( fileName );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Cache object if it's a part so it can be reused later.\r\n\t\t\tif ( isPartType( info.type ) ) {\r\n\r\n\t\t\t\tthis._cache[ key ] = promise;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return a copy\r\n\t\t\tconst group = await promise;\r\n\t\t\treturn group.clone();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// parses the given model text into a renderable object. Returns cached copy if available.\r\n\tasync parseModel( text ) {\r\n\r\n\t\tconst parseCache = this.parseCache;\r\n\t\tconst info = parseCache.parse( text );\r\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\r\n\r\n\t\t\treturn this.getCachedModel( info.fileName );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.processIntoMesh( info );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction sortByMaterial( a, b ) {\r\n\r\n\tif ( a.colorCode === b.colorCode ) {\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n\tif ( a.colorCode < b.colorCode ) {\r\n\r\n\t\treturn - 1;\r\n\r\n\t}\r\n\r\n\treturn 1;\r\n\r\n}\r\n\r\nfunction createObject( elements, elementSize, isConditionalSegments = false, totalElements = null ) {\r\n\r\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\r\n\t// With per face / segment material, implemented with mesh groups and materials array\r\n\r\n\t// Sort the faces or line segments by color code to make later the mesh groups\r\n\telements.sort( sortByMaterial );\r\n\r\n\tif ( totalElements === null ) {\r\n\r\n\t\ttotalElements = elements.length;\r\n\r\n\t}\r\n\r\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\r\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\r\n\tconst materials = [];\r\n\r\n\tconst quadArray = new Array( 6 );\r\n\tconst bufferGeometry = new BufferGeometry();\r\n\tlet prevMaterial = null;\r\n\tlet index0 = 0;\r\n\tlet numGroupVerts = 0;\r\n\tlet offset = 0;\r\n\r\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\r\n\r\n\t\tconst elem = elements[ iElem ];\r\n\t\tlet vertices = elem.vertices;\r\n\t\tif ( vertices.length === 4 ) {\r\n\r\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\r\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\r\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\r\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\r\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\r\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\r\n\t\t\tvertices = quadArray;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\r\n\r\n\t\t\tconst v = vertices[ j ];\r\n\t\t\tconst index = offset + j * 3;\r\n\t\t\tpositions[ index + 0 ] = v.x;\r\n\t\t\tpositions[ index + 1 ] = v.y;\r\n\t\t\tpositions[ index + 2 ] = v.z;\r\n\r\n\t\t}\r\n\r\n\t\t// create the normals array if this is a set of faces\r\n\t\tif ( elementSize === 3 ) {\r\n\r\n\t\t\tif ( ! elem.faceNormal ) {\r\n\r\n\t\t\t\tconst v0 = vertices[ 0 ];\r\n\t\t\t\tconst v1 = vertices[ 1 ];\r\n\t\t\t\tconst v2 = vertices[ 2 ];\r\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\r\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\r\n\t\t\t\telem.faceNormal = new Vector3()\r\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\r\n\t\t\t\t\t.normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet elemNormals = elem.normals;\r\n\t\t\tif ( elemNormals.length === 4 ) {\r\n\r\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\r\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\r\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\r\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\r\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\r\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\r\n\t\t\t\telemNormals = quadArray;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\r\n\r\n\t\t\t\t// use face normal if a vertex normal is not provided\r\n\t\t\t\tlet n = elem.faceNormal;\r\n\t\t\t\tif ( elemNormals[ j ] ) {\r\n\r\n\t\t\t\t\tn = elemNormals[ j ].norm;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst index = offset + j * 3;\r\n\t\t\t\tnormals[ index + 0 ] = n.x;\r\n\t\t\t\tnormals[ index + 1 ] = n.y;\r\n\t\t\t\tnormals[ index + 2 ] = n.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( prevMaterial !== elem.colorCode ) {\r\n\r\n\t\t\tif ( prevMaterial !== null ) {\r\n\r\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst material = elem.material;\r\n\r\n\t\t\tif ( material !== null ) {\r\n\r\n\t\t\t\tif ( elementSize === 3 ) {\r\n\r\n\t\t\t\t\tmaterials.push( material );\r\n\r\n\t\t\t\t} else if ( elementSize === 2 ) {\r\n\r\n\t\t\t\t\tif ( isConditionalSegments ) {\r\n\r\n\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial.userData.conditionalEdgeMaterial );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tmaterials.push( material.userData.edgeMaterial );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\r\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\r\n\t\t\t\tmaterials.push( elem.colorCode );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevMaterial = elem.colorCode;\r\n\t\t\tindex0 = offset / 3;\r\n\t\t\tnumGroupVerts = vertices.length;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnumGroupVerts += vertices.length;\r\n\r\n\t\t}\r\n\r\n\t\toffset += 3 * vertices.length;\r\n\r\n\t}\r\n\r\n\tif ( numGroupVerts > 0 ) {\r\n\r\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\r\n\r\n\t}\r\n\r\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\r\n\r\n\tif ( normals !== null ) {\r\n\r\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\r\n\r\n\t}\r\n\r\n\tlet object3d = null;\r\n\r\n\tif ( elementSize === 2 ) {\r\n\r\n\t\tif ( isConditionalSegments ) {\r\n\r\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\r\n\r\n\t\t}\r\n\r\n\t} else if ( elementSize === 3 ) {\r\n\r\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\r\n\r\n\t}\r\n\r\n\tif ( isConditionalSegments ) {\r\n\r\n\t\tobject3d.isConditionalLine = true;\r\n\r\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\r\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\r\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\r\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst os = elements[ i ];\r\n\t\t\tconst vertices = os.vertices;\r\n\t\t\tconst controlPoints = os.controlPoints;\r\n\t\t\tconst c0 = controlPoints[ 0 ];\r\n\t\t\tconst c1 = controlPoints[ 1 ];\r\n\t\t\tconst v0 = vertices[ 0 ];\r\n\t\t\tconst v1 = vertices[ 1 ];\r\n\t\t\tconst index = i * 3 * 2;\r\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\r\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\r\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\r\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\r\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\r\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\r\n\r\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\r\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\r\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\r\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\r\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\r\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\r\n\r\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\r\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\r\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\r\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\r\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\r\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\r\n\r\n\t\t}\r\n\r\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\r\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\r\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\r\n\r\n\t}\r\n\r\n\treturn object3d;\r\n\r\n}\r\n\r\n//\r\n\r\nclass LDrawLoader extends Loader {\r\n\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\t// Array of THREE.Material\r\n\t\tthis.materials = [];\r\n\t\tthis.materialLibrary = {};\r\n\r\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\r\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\r\n\r\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\r\n\t\tthis.fileMap = {};\r\n\r\n\t\t// Initializes the materials library with default materials\r\n\t\tthis.setMaterials( [] );\r\n\r\n\t\t// If this flag is set to true the vertex normals will be smoothed.\r\n\t\tthis.smoothNormals = true;\r\n\r\n\t\t// The path to load parts from the LDraw parts library from.\r\n\t\tthis.partsLibraryPath = '';\r\n\r\n\t\t// Material assigned to not available colors for meshes and edges\r\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\r\n\t\tthis.missingColorMaterial.name = 'Missing material';\r\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { color: 0xFF00FF } );\r\n\t\tthis.missingEdgeColorMaterial.name = 'Missing material - Edge';\r\n\t\tthis.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { fog: true, color: 0xFF00FF } );\r\n\t\tthis.missingConditionalEdgeColorMaterial.name = 'Missing material - Conditional Edge';\r\n\t\tthis.missingColorMaterial.userData.edgeMaterial = this.missingEdgeColorMaterial;\r\n\t\tthis.missingEdgeColorMaterial.userData.conditionalEdgeMaterial = this.missingConditionalEdgeColorMaterial;\r\n\r\n\t}\r\n\r\n\tsetPartsLibraryPath( path ) {\r\n\r\n\t\tthis.partsLibraryPath = path;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tasync preloadMaterials( url ) {\r\n\r\n\t\tconst fileLoader = new FileLoader( this.manager );\r\n\t\tfileLoader.setPath( this.path );\r\n\t\tfileLoader.setRequestHeader( this.requestHeader );\r\n\t\tfileLoader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tconst text = await fileLoader.loadAsync( url );\r\n\t\tconst colorLineRegex = /^0 !COLOUR/;\r\n\t\tconst lines = text.split( /[\\n\\r]/g );\r\n\t\tconst materials = [];\r\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst line = lines[ i ];\r\n\t\t\tif ( colorLineRegex.test( line ) ) {\r\n\r\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\r\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\r\n\t\t\t\tmaterials.push( material );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.setMaterials( materials );\r\n\r\n\t}\r\n\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst fileLoader = new FileLoader( this.manager );\r\n\t\tfileLoader.setPath( this.path );\r\n\t\tfileLoader.setRequestHeader( this.requestHeader );\r\n\t\tfileLoader.setWithCredentials( this.withCredentials );\r\n\t\tfileLoader.load( url, text => {\r\n\r\n\t\t\tthis.partsCache\r\n\t\t\t\t.parseModel( text, this.materialLibrary )\r\n\t\t\t\t.then( group => {\r\n\r\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\r\n\t\t\t\t\tthis.computeBuildingSteps( group );\r\n\t\t\t\t\tgroup.userData.fileName = url;\r\n\t\t\t\t\tonLoad( group );\r\n\r\n\t\t\t\t} )\r\n\t\t\t\t.catch( onError );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n\tparse( text, onLoad ) {\r\n\r\n\t\tthis.partsCache\r\n\t\t\t.parseModel( text, this.materialLibrary )\r\n\t\t\t.then( group => {\r\n\r\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\r\n\t\t\t\tthis.computeBuildingSteps( group );\r\n\t\t\t\tgroup.userData.fileName = '';\r\n\t\t\t\tonLoad( group );\r\n\r\n\t\t\t} );\r\n\r\n\t}\r\n\r\n\tsetMaterials( materials ) {\r\n\r\n\t\tthis.materialLibrary = {};\r\n\t\tthis.materials = [];\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.addMaterial( materials[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\r\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\r\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetFileMap( fileMap ) {\r\n\r\n\t\tthis.fileMap = fileMap;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\taddMaterial( material ) {\r\n\r\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\r\n\r\n\t\tconst matLib = this.materialLibrary;\r\n\t\tif ( ! matLib[ material.userData.code ] ) {\r\n\r\n\t\t\tthis.materials.push( material );\r\n\t\t\tmatLib[ material.userData.code ] = material;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tgetMaterial( colorCode ) {\r\n\r\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\r\n\r\n\t\t\t// Special 'direct' material value (RGB color)\r\n\t\t\tconst color = colorCode.substring( 3 );\r\n\r\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.materialLibrary[ colorCode ] || null;\r\n\r\n\t}\r\n\r\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\r\n\t// in the material array if they need to be filled in.\r\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\r\n\r\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\r\n\t\tconst loader = this;\r\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\r\n\t\tgroup.traverse( c => {\r\n\r\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\r\n\r\n\t\t\t\tif ( Array.isArray( c.material ) ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\r\n\r\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\r\n\r\n\t\t\t\t\tc.material = getMaterial( c, c.material );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\r\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\r\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\r\n\t\t// simply returned for the subsequent material application.\r\n\t\tfunction getMaterial( c, colorCode ) {\r\n\r\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\r\n\t\t\t// return early.\r\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\r\n\r\n\t\t\t\treturn colorCode;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\r\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\r\n\t\t\tif ( isPassthrough ) {\r\n\r\n\t\t\t\tcolorCode = parentColorCode;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet material = null;\r\n\t\t\tif ( colorCode in materialHierarchy ) {\r\n\r\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\r\n\r\n\t\t\t} else if ( finalMaterialPass ) {\r\n\r\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\r\n\t\t\t\t// parse the \"direct\" colors\r\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\r\n\t\t\t\tif ( material === null ) {\r\n\r\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\r\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\r\n\r\n\t\t\t\t\t// And return the 'missing color' material\r\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn colorCode;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c.isLineSegments ) {\r\n\r\n\t\t\t\tmaterial = material.userData.edgeMaterial;\r\n\r\n\t\t\t\tif ( c.isConditionalLine ) {\r\n\r\n\t\t\t\t\tmaterial = material.userData.conditionalEdgeMaterial;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetMainMaterial() {\r\n\r\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\r\n\r\n\t}\r\n\r\n\tgetMainEdgeMaterial() {\r\n\r\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\r\n\t\treturn mat ? mat.userData.edgeMaterial : null;\r\n\r\n\t}\r\n\r\n\tparseColorMetaDirective( lineParser ) {\r\n\r\n\t\t// Parses a color definition and returns a THREE.Material\r\n\r\n\t\tlet code = null;\r\n\r\n\t\t// Triangle and line colors\r\n\t\tlet color = 0xFF00FF;\r\n\t\tlet edgeColor = 0xFF00FF;\r\n\r\n\t\t// Transparency\r\n\t\tlet alpha = 1;\r\n\t\tlet isTransparent = false;\r\n\t\t// Self-illumination:\r\n\t\tlet luminance = 0;\r\n\r\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\r\n\r\n\t\tlet edgeMaterial = null;\r\n\r\n\t\tconst name = lineParser.getToken();\r\n\t\tif ( ! name ) {\r\n\r\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\r\n\r\n\t\t}\r\n\r\n\t\t// Parse tag tokens and their parameters\r\n\t\tlet token = null;\r\n\t\twhile ( true ) {\r\n\r\n\t\t\ttoken = lineParser.getToken();\r\n\r\n\t\t\tif ( ! token ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! parseLuminance( token ) ) {\r\n\r\n\t\t\t\tswitch ( token.toUpperCase() ) {\r\n\r\n\t\t\t\t\tcase 'CODE':\r\n\r\n\t\t\t\t\t\tcode = lineParser.getToken();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'VALUE':\r\n\r\n\t\t\t\t\t\tcolor = lineParser.getToken();\r\n\t\t\t\t\t\tif ( color.startsWith( '0x' ) ) {\r\n\r\n\t\t\t\t\t\t\tcolor = '#' + color.substring( 2 );\r\n\r\n\t\t\t\t\t\t} else if ( ! color.startsWith( '#' ) ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'EDGE':\r\n\r\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\r\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\r\n\r\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\r\n\r\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\r\n\r\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\r\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\r\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\r\n\r\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\r\n\t\t\t\t\t\t\tedgeMaterial = edgeMaterial.userData.edgeMaterial;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ALPHA':\r\n\r\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\r\n\r\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\r\n\r\n\t\t\t\t\t\tif ( alpha < 1 ) {\r\n\r\n\t\t\t\t\t\t\tisTransparent = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'LUMINANCE':\r\n\r\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\r\n\r\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CHROME':\r\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'PEARLESCENT':\r\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'RUBBER':\r\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'MATTE_METALLIC':\r\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'METAL':\r\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'MATERIAL':\r\n\t\t\t\t\t\t// Not implemented\r\n\t\t\t\t\t\tlineParser.setToEnd();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet material = null;\r\n\r\n\t\tswitch ( finishType ) {\r\n\r\n\t\t\tcase FINISH_TYPE_DEFAULT:\r\n\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\r\n\r\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.3, metalness: 0.25 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FINISH_TYPE_CHROME:\r\n\r\n\t\t\t\t// Mirror finish surface\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0, metalness: 1 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FINISH_TYPE_RUBBER:\r\n\r\n\t\t\t\t// Rubber finish\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.9, metalness: 0 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\r\n\r\n\t\t\t\t// Brushed metal finish\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.8, metalness: 0.4 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase FINISH_TYPE_METAL:\r\n\r\n\t\t\t\t// Average metal finish\r\n\t\t\t\tmaterial = new MeshStandardMaterial( { color: color, roughness: 0.2, metalness: 0.85 } );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\t// Should not happen\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.transparent = isTransparent;\r\n\t\tmaterial.premultipliedAlpha = true;\r\n\t\tmaterial.opacity = alpha;\r\n\t\tmaterial.depthWrite = ! isTransparent;\r\n\t\tmaterial.color.convertSRGBToLinear();\r\n\r\n\t\tmaterial.polygonOffset = true;\r\n\t\tmaterial.polygonOffsetFactor = 1;\r\n\r\n\t\tif ( luminance !== 0 ) {\r\n\r\n\t\t\tmaterial.emissive.set( material.color ).multiplyScalar( luminance );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! edgeMaterial ) {\r\n\r\n\t\t\t// This is the material used for edges\r\n\t\t\tedgeMaterial = new LineBasicMaterial( {\r\n\t\t\t\tcolor: edgeColor,\r\n\t\t\t\ttransparent: isTransparent,\r\n\t\t\t\topacity: alpha,\r\n\t\t\t\tdepthWrite: ! isTransparent\r\n\t\t\t} );\r\n\t\t\tedgeMaterial.userData.code = code;\r\n\t\t\tedgeMaterial.name = name + ' - Edge';\r\n\t\t\tedgeMaterial.color.convertSRGBToLinear();\r\n\r\n\t\t\t// This is the material used for conditional edges\r\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\r\n\r\n\t\t\t\tfog: true,\r\n\t\t\t\ttransparent: isTransparent,\r\n\t\t\t\tdepthWrite: ! isTransparent,\r\n\t\t\t\tcolor: edgeColor,\r\n\t\t\t\topacity: alpha,\r\n\r\n\t\t\t} );\r\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.color.convertSRGBToLinear();\r\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.userData.code = code;\r\n\t\t\tedgeMaterial.userData.conditionalEdgeMaterial.name = name + ' - Conditional Edge';\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.userData.code = code;\r\n\t\tmaterial.name = name;\r\n\r\n\t\tmaterial.userData.edgeMaterial = edgeMaterial;\r\n\r\n\t\tthis.addMaterial( material );\r\n\r\n\t\treturn material;\r\n\r\n\t\tfunction parseLuminance( token ) {\r\n\r\n\t\t\t// Returns success\r\n\r\n\t\t\tlet lum;\r\n\r\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\r\n\r\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlum = parseInt( token );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isNaN( lum ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomputeBuildingSteps( model ) {\r\n\r\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\r\n\r\n\t\tlet stepNumber = 0;\r\n\r\n\t\tmodel.traverse( c => {\r\n\r\n\t\t\tif ( c.isGroup ) {\r\n\r\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\r\n\r\n\t\t\t\t\tstepNumber ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tc.userData.buildingStep = stepNumber;\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { LDrawLoader };\r\n"],"names":["MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","Vector3","_tempVec1","LDrawConditionalLineMaterial","_ShaderMaterial","_inherits","_super","_createSuper","parameters","_this","_classCallCheck","call","uniforms","UniformsUtils","merge","UniformsLib","fog","diffuse","value","Color","opacity","vertexShader","fragmentShader","Object","defineProperties","_assertThisInitialized","get","this","set","color","setValues","isLDrawConditionalLineMaterial","_createClass","ShaderMaterial","ConditionalLineSegments","_LineSegments","_super2","geometry","material","_this2","isConditionalLine","LineSegments","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","Ray","smoothNormals","lineSegments","checkSubSegments","arguments","undefined","hashMultiplier","hashVertex","v","x","y","z","concat","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","add","rh1","has","rh2","info","distances","d0","d1","_ref","push","tri","vertCount","i2","index","next","hash","rayHash","_ref2","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","charAt","pos0","pos1","seekNonSpace","substring","parseFloat","getToken","LDrawParsedCache","loader","_cache","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","author","subobjects","fileName","totalFaces","startingBuildingStep","materials","group","_fetchData","_asyncToGenerator","_regeneratorRuntime","mark","_callee","triedLowerCase","locationState","subobjectURL","fileLoader","text","wrap","_context","prev","t0","abrupt","lastIndexOf","toLowerCase","FileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","sent","t1","Error","stop","_x","apply","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","isAtTheEnd","lineType","segment","doubleSided","v3","meta","parseColorMetaDirective","userData","code","console","warn","getLineNumberString","newKeywords","getRemainingString","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","Matrix4","fileMap","inverted","getVector","Promise","cloneResult","_ensureDataLoaded","_callee2","_this3","_context2","fetchData","then","parse","_x2","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","LDrawPartsGeometryCache","parseCache","_processIntoMesh","_callee4","faceMaterials","processInfoSubobjects","_this4","_context5","_ref3","_callee3","subobject","promises","_loop","subobjectInfos","_i5","_l4","_subobject","subobjectInfo","subobjectGroup","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","lineColorCode","_i6","_l5","ls","_i7","_l6","os","_vertices3","_i8","_l7","_vertices4","_i9","_l8","_args4","_context4","promise","_context3","ensureDataLoaded","getData","test","loadModel","catch","error","delegateYield","Group","all","isGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","determinant","applyMatrix4","reverse","_x4","size","createObject","_x3","_getCachedModel","_callee5","_context6","hasCachedModel","_x5","_loadModel","_callee6","_context7","getCachedModel","processIntoMesh","_x6","_parseModel","_callee7","_context8","_x7","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","BufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","BufferAttribute","object3d","Mesh","controlArray0","controlArray1","directionArray","c0","c1","LDrawLoader","_Loader","_super3","_this5","materialLibrary","partsCache","setMaterials","missingColorMaterial","MeshStandardMaterial","roughness","metalness","missingEdgeColorMaterial","LineBasicMaterial","missingConditionalEdgeColorMaterial","path","_preloadMaterials","_callee8","url","colorLineRegex","directive","_context9","_x8","onLoad","onProgress","onError","_this6","load","parseModel","computeBuildingSteps","_this7","addMaterial","matLib","finalMaterialPass","parentIsPassthrough","getMaterial","c","isLineSegments","traverse","isMesh","isArray","isMaterial","mat","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","parseLuminance","toUpperCase","parseInt","isNaN","max","min","setToEnd","transparent","premultipliedAlpha","depthWrite","convertSRGBToLinear","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","lum","model","stepNumber","buildingStep","numBuildingSteps","Loader"],"sourceRoot":""}